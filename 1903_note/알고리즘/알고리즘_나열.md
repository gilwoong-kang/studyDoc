### Compare Sort

1. Insertion Sort

![image-20191015123913177](image/image-20191015123913177.png)

#### Divide And Conquer

1. Merge Sort

   ![image-20191015124303937](image/image-20191015124303937.png)

![image-20191015124237332](image/image-20191015124237332.png)

2. Brute-force (주먹구구)

![image-20191015124950730](image/image-20191015124950730.png)

![image-20191015125028502](image/image-20191015125028502.png)

3. Matrix Multiplication

   - Brute force Matrix Multiplication![image-20191015125115615](image/image-20191015125115615.png)

   - Strassen’s (Divide-and-Conquer) matrix multiplication

#### Recurrence

1. 치환법 (substitution method)

![image-20191015125751654](image/image-20191015125751654.png)

2. 재귀 트리 방법

3. 마스터 방법

#### 확률적 분석과 랜덤화된 알고리즘

1. 고용 알고리즘

![image-20191015130132585](image/image-20191015130132585.png)$$O(c_hn)$$ -> 매번 다음 지원자가 이전 지원자보다 유능할 때 (Worst case)

2. 지표 확률변수의 예 - 동전 던지기

확률적 분석을 할 때는 입력의 분포에 따라 계산하여 average-case cost (or running time) 을 계산

랜덤화된 알고리즘을 분석할 때는 입력의 분포와 상관없이 expected cost (or running time) 을 계산 

#### Sort

1. Heap sort

![image-20191015130657900](image/image-20191015130657900.png)

2. Quick Sort

<img src="image/image-20191015130813660.png" alt="image-20191015130813660" style="zoom:50%;" />

3. Counting Sort

<img src="image/image-20191015131003255.png" alt="image-20191015131003255" style="zoom:40%;" />

4. Radix Sort

5. Bucket Sort

<img src="image/image-20191015131132111.png" alt="image-20191015131132111" style="zoom:50%;" />

#### Dynamic Programming

- rod cutting

  1. Top Down

     <img src="image/image-20191015131434944.png" alt="image-20191015131434944" style="zoom:23%;" />

  2. Bottom Up

     <img src="image/image-20191015131455917.png" alt="image-20191015131455917" style="zoom:23%;" />

- matrix-chain multiplication

  ![image-20191015131620672](image/image-20191015131620672.png)

- longest common subsequence

