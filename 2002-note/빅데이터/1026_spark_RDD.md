## 빅데이터

### 스파크 핵심개념 - Resilient Distributed Datasets(RDD)

데이터가 실제적으로 분산적으로 분산되어 있을 때. 하둡은 명시적으로 블락 자체를 하둡 프로그램에 전달만 해주는 작업인데 스파크는 그것을 좀더 느슨하게. 데이터 자체를 바로 사용자가 접근 할 수있도록 했다. 그것이 바로 RDD.

블락이 dfs레이어와 processing 레이어로 나뉘었다고 하면, dfs레이어에 파일이 블락으로 쪼개져 있고 프로세스 레이어에서 파일이 하나의 객체로 인식. 파일이 실제로 존재하는것은 아님. 블럭단위로 쪼개져 있기 때문. 하지만 사용자 입장에서는 이것이 실제로 있는것처럼 보이고 실제로 명령 내릴 수 있음. 

스파크 작업의 시작점이다. 파일을 불러와야 맵 리듀스 등 실행 가능하기 때문.

**프로그래머는 RDD가 어디에 저장되는지 지정 가능하다.** 이것이 중요한데, RDD가 실제로 어디에 저장 할지, 메모리에 저장할지 디스크에 저장할지 아니면 실시간으로 연산에 반영할지 결정 할 수 있다. 스파크를 필요한 RDD를 이용해 사용자가 적절히 지정하여 운용해야 하둡보다 빠른 것이다. 

RDD라는 것이 분산된 블락을 하나의 파일로 추상화 시켜서 사용자가 이용할 수 있도록 한 엔트리 포인트라고 볼 수 있다.

#### Transformation과 Action

전자는 존재하는 RDD에 대해 수정하여 새로운 RDD를 만들어낸다. 인풋이 RDD 아웃풋이 새로운 RDD.

액션은 인풋 RDD고 아웃풋이 RDD가 아님. 어레이일수도 있고 뭐 스트링일수도 있고... RDD로부터 연산후 값을 반환함.

> Lazy evaluation : 트랜스포메이션은 즉각 실행되는게 아님. 액션이 실행이 되면 그때 차례대로 트랜스포메이션이 실행된다. 
>
> 왜 이렇게 하느냐면, 스파크 코어엔진 최적화를 해줌. 연산 순서에 대함.
>
> ```scala
> val action_movies = movies.filter(movie => movie.contains("action")) // transformation
> action_movies.count()	// action
> ```
>
> Lazy evaluation 없다면, 무비 RDD로부터 '액션'이 포함된 RDD생성. 이후 카운트 실행됨. 
>
> 있으면 중간 결과인 movies가 필요없고, 읽어들이면서 바로 action 키워드의 첨가 여부를 확인해 카운트 리턴.
>
> 요점은 트랜스포메이션을 스파크에서 적절히 최적화 하기 때문에 필요한 것.

#### Lineage

RDD객체가 만들어지기까지 일어난 트랜스포메이션을 기록해 논것. 드라이버 프로세스가 RDD의 Lineage를 기록하고 있다가 메모리가 날아가는 등 유실될 경우 특정 버전의 객체를 생성 할 수 있도록 함. 

### RDD transformations

##### Map

##### flatMap

맵과 비슷한데, 최종적으로 나오는 결과가 조금 다름. 각 원소의 결과값이 최종 합해서 전체가 하나의 List로 반환되도록 함. 

