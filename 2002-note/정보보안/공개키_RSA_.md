## 정보보안

### 공개키 알고리즘

메세지가 크다는 전제하에 메세지를 대칭키로 암호화하고 대칭키를 공개키로 암호화한다. 메세지를 대칭키로 암호화한 값과 대칭키를 암호화한 값을 보낸다. 

메세지에 서명하는 것과 메세지의 해시값에 대해 서명하는 것을 동등한 보안으로 본다. 서명한 h(m)과 받아온 m를 해시한 값을 비교한다. 그 값이 같으면 서명한 것으로 간주해 메세지를 이용한다. 

#### Diffie-Hellman

- discrete logarithms

  discrete logarithms문제에서 고안한다. $$y=a^x$$ 가 주어졌을때 $$y,x$$ 가 주어진다면 이것이 충분한 수라고 할 때 a를 맞추기가 굉장히 어렵다. 하지만$$a,x$$ 가 주어지면 y값 찾기가 쉽다.

  y가 주어질때 p*q 를 구하는 것은 어렵다. 하지만 p,q를 주고 y를 찾는것은 쉽다. RSA는 이런 소인수 분해에서 도출된 알고리즘.

앨리스와 밥이 대칭키로 통신한다고 한다. 대칭키를 공유하는 것이 어렵다. 앨리스는 큰 소수p와 그것보다 작은수 g를 가진다. 이것이 쌍으로 이루어 공개키이다. 이것을 밥에게 보낸다. 그다음 앨리스가 x라는 넘버를 생성한다. 이것은 알려주면 안되는 값이다. 앨리스는 $$g^xmod (p)$$를 한 값을 전달한다. 밥은 $$g^ymod(p)$$ 값을 전달한다. 앨리스는 받은 값에 대해 x승을 곱한다.$$(g^ymod(p))^xmod(p)$$ 이 값의 결과는 $$g^{yx}mod(p)$$ 밥도 동일한 과정 하면 $$g^{xy}mod(p)$$ 두 값을 비교하면 값이 같은 값이다. 키의 길이는 p의 값만큼 나오게 되는것. 

공격자는 p,g,$$g^xmod(p),g^ymod(p)$$ 를 안다. 그런데 이것을 가지고 x와 y를 알아낼 수 없다. 이것이 discrete logarithms의 문제이다. 

x,y,p,g는 충분히 큰 값이여야 한다. 

#### RSA

- ((a mod n) + (b mod n)) mod n = (a+b) mod n
- ((a mod n) - (b mod n)) mod n = (a-b) mod n
- ((a mod n) * (b mod n)) mod n =(a*b) mod n 
- ((a mod n)^b) mod n = a^b mod n

앨리스가 공개키 알고리즘 이용을 위해 큰 소수 p와 q를 생성한다. 
n을 계산. n=p*q 
$$\phi$$(n) = (p-1)(q-1) 
e값을 구한다. $$e,1<e<\phi(n),gcd(e,\phi(n))=1$$을 만족하는 것을 찾는다. 파이n과 공통으로 나누어지는 수가 없는 e를 구하는 것이다. 서로소가 되는 e를 찾는것. gcd는 소인수분해.

**e\*d = 1 mod $$\phi(n)$$ 를 만족하는 d를 생성한다.** 이게 핵심 e와 곱해졌을때 나머지가 1인 수. 

**<u>(e*d) mod $$\phi(n)$$ = 1 인 d를 찾는것임. 중요</u>** 

k의 개인키  = (d,n) , k의 공개키 = (e,n) 