## 정보보안

사용자가 서버에 메세지를 보낼 때, 메세지에 대한 내용을 서버와 사용자만 알도록 해야한다(confidentiality). 중간 내용이 변조되지 않도록(integrity). 메세지를 받지 않았다고 우기는 일이 없도록(non-repudiation). 효율성이 있도록 하는것 필요.(efficiency) **<u>네가지 중요.</u>**

보통 세가지 기술 사용.

- 암호기술 중 시메트릭 키 알고리즘(대칭키)

- 공개키(어시메트릭 키/비대칭키)

- 해시함수 cryptographic hash

#### 대칭키

메시지 주어졌을때 알고리즘에 넣어서 키값을 아는 사람만 해독할 수 있도록 하는 것을 대칭키 알고리즘.

> $$K_s$$ 라는 것은 시메트릭 키 라고 함. 키를 사용해서 암호화 하는 것을 의미.

원본으로 돌아오게 하기 위해서는 $$K_s$$ 동일 키가 필요. $$K_s(K_S(m))=m$$

#### 비 대칭키

개인키 공개키 키 쌍을 가지고 있음. 두개의 키. $$K_A^- K_A^+$$ ,(-가 개인키) 공개키로 암호화 하고 이것을 풀 수 있는 방법은 개인키로만 가능하다. 반면에 개인키로 암호화 한것은 서명 했다라고 한다. 개인키로 암호화 한것은 대응되는 공개키로 해독한다. 

#### 암호학적 해시

메시지를 암호학적 해시를 적용하면 일정한 용량으로 축소되게 된다. 예를들어 256비트. 이 256비트의 값끼리가 동일할 확률은 매우 적다. 

#### 예시

앨리스(사용자)와 밥(서버) 통신. 앨리스가 밥에게 정보를 보낸다고 한다. 밥은 그러면 앨리스에게 공개키를 보낸다. 앨리스는 세션키$$K_s$$를 하나 생성한다.(대칭키) 밥이 준 공개키를 이용해서 이 세션키를 암호화$$K_B^+(K_s)$$ 한다. 그리고 보내고자 하는 메시지를 세션키를 가지고 암호화$$K_s(m)$$ 한다. 원본 메세지에 해시함수를 적용하고 앨리스의 개인키로 암호화(전자서명)$$K_A^-(H(m))$$ 한다. 

이렇게 하는 이유는 4가지를 만족해야 하기 때문이다. 

그래서 총 세가지 $$K_B^+(K_s),K_s(m),K_A^-(H(m))$$ 를 밥이 받는다. 그러면 밥의 개인키로 $$K_s$$ 를 얻어내고 메세지를 해독한다. 그리고 해독된 메세지를 가지고 해시를 적용시킨뒤 앨리스가 보낸것과 비교해 서명을 확인한다.

해시함수가 동일한 가치를 지닌다고 할 수 있기 때문에 Non-repudiation만족. 해시값이 동일하기 때문에 integrity만족. 메세지에 대해 바로 서명하게 하면 매우 느림. 세션키를 가지고 해시로 만든다음에 암호화 하여 효율성도 만족. 세션키를 암호화 하여 효율성을 만족. 



여기서 문제가 있는데, 밥이 처음에 내려준 공개키가 신뢰 할수 있는지에 대한 문제이다. 때문에 CA라고 하는 인증 기관을 도입 하게 됌. 인증 기관도 자신의 공개,개인 키가 있다. 밥이 자신의 공개키를 내려줄 때 인증기관의 서명을 받는다.$$K_{CA}^-(K_B^+,Bob)$$ 이렇게 받은 인증된 키를 내려준다. 앨리스는 이것을 받아 CA의 공개키로 밥이 준 값을 해독한다. 그러면 공개키와 밥의 서명을 받게 된다. 



그러면 또 CA의 공개키가 정당한 것인지 검증해야 하는 문제가 발생하는데, 이 문제를 해결 하기 위해 브라우저를 처음 설치 할때 공인된 상위 인증기관의 키는 내장되어 설치하게 된다. 