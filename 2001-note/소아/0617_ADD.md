## Attribute Driven Design 

카네기 말론 대학에 있는 SEI에서 아키텍처 설계시 좀 더 매커니즘적으로 하는 알고리즘을 고안한 것. 비용 효율적, 반복적 도출 가능. 여러가지 재활용 가능한 디자인 스트래테지를 구성 가능하다. 

앞서 UP를 배웠는데, UP는 반복과 인크리멘탈(점진적)으로 완성도에 맞추어 가는 것. 

이에 반해 ADD는 시스테믹 하고 재귀적으로 문제를 계속 분해해가면서 분석하는 것. 재귀와 분해해 나가는 것이 핵심임. (Recursive, decomposition) 점점 분해해 나가면서 세부 설계 하는것. 아키텍처 스타일과 방안을 집어넣어 설계에 반영하는 개발 공정론.

기본적으로 

##### Plan

계획하고. 아키텍처를 구성하는 동기가 되는 요소. 어떤 엘리먼트를 선택하여 설계할지.

##### do 

실행하고. 세부 설계를 한다. 

##### check

검증함. 전체 구조가 적절한 다른 구조와 연결이 다 잘 되는지 점검.

위 세가지를 계속 반복한다. 아키텍처의 결과가 반영 될 때까지 지속. 

Add방법론은 전체 구조가 나왔으면 나누어 ADD를 실시하고 다시 실시하고...

 <img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 10.51.47.png" alt="스크린샷 2020-06-17 오후 10.51.47" style="zoom:67%;" />

하다보니까 일부가 또 디컴포지션 해야할거 같아.. 또하고. (예를들어 다른 패턴이라던가 스트레테지 패턴등의 이유로 더 쪼개는게 좋다고 고려 될 경우) 

전체 사이클이 리커시브하게 계속적으로 디컴포즈를 해 나가는 형태. 이렇게 하면 전체구조가 더 나은 방향으로 간다. 

<img src="image/스크린샷 2020-06-17 오후 11.13.16.png" alt="스크린샷 2020-06-17 오후 11.13.16" style="zoom:67%;" />

아키텍처 드라이버가 있다. 이것을 스택홀더와 결정한 것. 목적이라던가 퀄리티 어트리뷰트, 기능 , 제한사항, 등이다. 그릭고 설계 전략이 있는데 아키텍트는 이 설계 전략을 가지고 구상하여 반영하는 것이다. 

### ADD 3.0

<img src="image/스크린샷 2020-06-17 오후 11.14.44.png" alt="스크린샷 2020-06-17 오후 11.14.44" style="zoom:67%;" />

먼저 인풋을 가져온다. 드라이버를 선택한다. 그리고 우선순위 결정함. 기능성에 대해 선택해도 되고 퀄리티 어트리뷰트를 선택 할 수도있다. 이렇게 어트리뷰트를 선택한뒤 어디에 적용할지 선택함. 그에따라 디자인 컨셉을 결정함. 여기서 아케틱처 스타일을 적용한다. 아키텍처 스타일로 내부를 만들어 나간다. 동시에 책임을 주고, 이후 전체에 디한 뷰를 하고 이후 분석을 하고... 검토하고  여기까지 내용을 다시 반복한다. 

##### 1. 리뷰 인풋

서로 합의에 의해 결정한 사항. Purpose, primary functional requirements, quality attribute scenarios, constraints, concerns...

##### 2. 드라이버 선택

드라이버 5가지 중 어떠한 드라이버가 핵심인지 선택을 하게 됌. 선택한 것을 목표에 맞추어 설계. 드라이버 전체 요구사항을 만족할 때 설계 진행.

##### 3. 리파인 하기위해 엘리먼트 선택.

리파인은 디컴포지션이라는 의미가 들어감. 계속적으로 스타일을 넣으며 만드는것. 큰 덩이의 것을 작은것으로 나누면서 분해해가는 것. 하다보니 잘게 나누어진 것이 있는데 이것을 하나로 합친다. 어떤 오브젝트 형태로 만드는 것. 합쳐나가는 형태의 어프로치도 있음. 또 하나는 임프로브로, 이미 있는 엘리먼트인데 더 좋은 엘리먼트로 메소드를 더 만든다거나 이러한 작업을 하는것. 위의 것을 포함하는 것이 리파인이다. (세가지를 포함하는 의미임.)

##### 4. 하나 이상의 스타일을 선택한다.

아키텍처 스타일 등을 선택하여 집어넣음. 이외에도 디자인 패턴들을 적용한다거나도 가능. 

##### 5. 내부를 인스턴시에이트를 만들고 책임을 부여하고 인터페잉스를 정의함.

내부를 더 구체적으로 만들면서 외부와 잘 작동하게 함. 

##### 6. 전체 액티비티가 제대로 수행 되는지 테스트.

테스트. 추가 드라이버등 추가하는 행위

##### 7. 현재 설계 분석하고 리뷰한 다음 디자인 목적에 맞는지 점검.



상위 모듈에서 우리가 여러 드라이버들을 선택항여 상위 모듈을 디컴포즈 하여 리파인. 하위모듈로 분해하며 작업을 해나간다. 기존의 배웠던 아키텍쳐 스타일 가지고 목적을 달성하게 된다. 