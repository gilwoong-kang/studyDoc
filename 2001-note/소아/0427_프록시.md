## 아키텍쳐

### 프록시 아키텍쳐

진짜가 아닌 가상의 연결점이라고 보면 된다. 외부의 오브젝트가 있다. 이것은 Distributed 오브젝트라고 하고 이것은 노드에 있다. 그리고 클라이언트가 있다. 디스트리뷰트는 굉장히 헤비한데, (디비가 달리거나 큰 시스템이 연결됨.) 이것을 클라이언트가 돌릴 수 없는데, 이때 클라이언트 노드 안에 프록시를 넣는 것이다. 외부에 있는 리모트한 노드의 분산 객체에 해당되는 것. 이 클라이언트는 내 노드에 있는 오브젝트를 호출하듯이 이용하면 되고, 프록시는 외부에 있는 노드의 오브젝트를 이용하는 것이다. 

다른 오브젝에 대한 surrogate를 제공. 진짜는 아니지만 모든것을 제공하는 껍데기. 모든 메소드 콜은 인다이렉트하게 간다. 디스트리뷰트를 직접 호출이 아니고 프록시를 간접적으로 불러 호출. 프록시는 실제 있는 오브젝트에 관련된 인터페이스를 공유해서 마치 이 클라이언트 프로세스가 디스트리뷰트 오브젝트를 직접 연결하는 듯한 환상을 제공한다. 

프록시를 하게 되는 경우에서 디스트리뷰트를 실행하는 것은 서버단에서 실행이 되는 것으로 볼 수 있다.

##### Context

Transparent manegement를 할수있다(투명성) 현실화된 오브젝트가 있는데, 내부적으로 인식하지 않아도 그 현실적인 오브젝트를 실행 될 것이라는 믿음을 가지고 투명성을 제공한다. 

다른 오브젝트에 대한 투명한 관리를 가짐. 

리얼한 오브젝트를 담당해서 인보케이션 해 줄수 있다. 메소드가 리얼한 오브젝트를 인보케이션 하고 그것이 완료되면 그 시점에 리턴값을 주게 된다.  프록시는 클라이언트에 없는데 있는것 같은 환상을 가지게 되어 로컬에서 사용하는 것처럼 한다. (Remote proxy)

Access control. 외부에 리모트 하려 하는데, 복잡한 절차가 있다고 하자. 관리자 입장에서 직접 접근 하고 싶은데 이것에 대한 제공자를 제공할 수 있다. remote한 오브젝트를 접근하는 접근자를 프록시로 제공. 우리가 원하는 접근을 해주도록 함

Virtual proxy. 로컬쪽에서 실제로 리모트한 서버에 접근을 하지 않음. 내부에 대한 테스팅을 수행할 때, 아직 구현되지 않은 기능에 대해 테스팅을 수행할때 외부의 것이 개발되어 있지 않으면 테스팅이 불가능한데, 프록시를 두어 마치 작업을 수행한 것처럼 보이게 하여 테스팅을 수행 할 수 있도록 한다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-27 오후 2.31.20.png" alt="스크린샷 2020-04-27 오후 2.31.20" style="zoom:50%;" />

##### Dynamics

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-27 오후 2.32.29.png" alt="스크린샷 2020-04-27 오후 2.32.29" style="zoom:67%;" />

Client-Proxy / Service는 다른 노드임. 마셜링 프로세스가 필요함. 외부 오브젝트와 커뮤니케이션 할때 시리얼라이제이션 하는 형태를 마셜링,언마셜링이라고 함.

##### 장점

오리지널한 디스트리뷰트 오브젝트를 접근할 수 잇는 장점. 내부에 가지지 않고 프록시만 가지고 외부의 컨트롤 할 수 있다는 장점. 클라이언트의 리소스 세이브. 퍼포먼스도 분리되어 이득.

하우스키핑(유지보수) 헤비한 서버한쪽을 유지보수 하고 클라이언트는 기능적 유지보수. 

포텐셜 오버킬. 프록시가 어떤 경우에는 여러다리 걸치는 것일 수도있다. 여러 티어일수도 있다는 의미인데, 계속적으로 인다이렉트 레벨이 많아질 수 있는데 네트워크를 통해서 가야하는 것이 많아질 수 있어서 언제 폭탄이 터질지 모르는 위험부담이 존재. 만일 소식이 안온다면 어느 프록시나 네트워크가 잘못된건지 파악하기가 어려움. 추적관리가 어렵고 테스팅도 어렵다. 여러 단계에 걸친다면 좋지 않음. 