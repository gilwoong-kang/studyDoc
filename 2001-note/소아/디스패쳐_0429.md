## 아키텍쳐

### 디스패쳐 아키텍쳐 - 로드밸런서

디스패쳐는 만약에 클라이언트의 관련된 시스템 근처에 디스패쳐가 있다면 통상 디스패쳐는 외부에 있는 다양한 서버에 대해 스위치 역할을 하게 된다. 서버를 셀렉팅 하는 역할을 하는 것이다. 디스패쳐를 서버단에 넣게 되면, 외부에서 들어오는 리퀘스트를 디스패쳐가 받아서 이 서버의 하나에게 넘겨주는 형태의 역할을 하게 된다. 외부에서는 디스패쳐에게 대표로 주게 되는것. 이 디스패쳐를 가지고 있는 마스터가 있다. 이 마스터각 여러개의 서버중 하나에게 리퀘스트를 던져준다. 

많은 클라이언트들이 리퀘스트를 하게 되면 디스패쳐의 역할에 따라 전체 서버군을 이루는 서버들에게 로드를 밸런싱하는 효과를 얻게 되는 것이다. 

디스패쳐는 클라이언트에 붙이는 것 보다도 서버에 붙이는 것이 더 효과적이다. 로드밸런서로서 사용이 가능해지기 때문이다.  서버들이 부하 받지 않고 균형적이게 일을 처리하도록 함. 중간과정의 미들웨어를 형성하고 있다. 서버는 farms구조. 클라이언트는 마치 하나의 서버를 이용하는 효과. High scalability, high availability. 높은 이용률과 확장성.

하나의 서버가 모든 요청을 처리하게 되면 많은 트래픽에대한 처리는 어렵다. 이 서버를 scale up 해야 한다. 코어를 더 붙이거나 더 메모리를 붙이는 방법이다. 그런데 이 스케일업은 통상 짧은 교체 기간을 가지기에 좋지않다. 서버를 더 붙여 나갈 수 있는 scale out이 좋음. 트래픽이 증가 되더라도 서버를 계속해서 증가시켜 나가는 솔루션이 더 적절.

디스패쳐는 이런 스케일 아웃에 대한 솔루션. 어플리케이션에 대한 리퀘스트를 처리하도록 함. 

어플리케이션 세션을 유지할 필요성 있음. 많은경우 http프로토콜에서는 스테이트를 유지하지 않는다. 그래서 많은 방법을 이용하는데, 쿠키를 이용한다거나, 서버에서 세션을 유지시켜서 이용한다거나 http요청에 스테이트를 담아서 객체로 보내는 등 방법을 취한다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-29 오전 10.43.30.png" alt="스크린샷 2020-04-29 오전 10.43.30" style="zoom:67%;" />

들어오는 요청에 따라 로드 밸런서는 적절하게 서버에게 분배해서 넘겨줌. 

#### Availability

가용성, 서버가 계속 가동되어 서비스를 제공 하게 하는. uptime : failures사이의 서비스가 게재하는 시간을 업타임이라고 한다. 업타임의 반대는 다운타임. failure에 대해 수리하거나 디텍트, 보완 하거나 재 시작하는 등 모든 것을 의미.  업타임 동안 리퀘스트를 잘 처리하도록 하고 잘 유지되도록. 

High availability(HA) 라고 하고, 7일,24시간,365일 항상 동작하도록. 한 서버만 가지고는 Availability하게 할 수 없음. HA를 제공하기 위해서 여러 서버를 제공해야 한다. 한 서버가 실패하더라도 다른 서버가 투명하게 받아 처리 하게 해줄 수 있는 형태가 바람직 하다. 

#### Scalability

확장성. 기능적 확장이 있고, 시스템의 규모를 확장하는 것이있는데, Scalability는 규모의 확장을 말하는 것임. 성능 이슈와 더불어 확장을 게시한다. Res time 등을 만족하기 위함이다. 

High scalable system을 만족하기 위해 scale up 하지 않고 scale out해서 달성한다. 들어오는 리퀘스트를 서버들에게 분산시켜서 업무들을 다른 서버에서 할 수 있도록 함.

로드밸런서가 bottleneck하게 되지 않도록 주의. 로드밸런서는 리퀘스트를 전달만 하는 역할만 할것. 로드밸런서는 서버의 상태를 모니터 하고 적절하게 전달해야한다. 

어느 경우에는 로드 밸런서 자체를 여러개를 두는 경우도 있음.

#### Implementations

트랜스포트 레벨에서 로드밸런스 하는것을 생각해 볼 수 있다. 디스패쳐에서 패킷이 오면, 트랜스포트 레이어에서 열어봐서 서버단에 패킷을 넘기는 방법이 있다. DNS를 기반으로 하거나 TCP/IP에서 할 수도 있음.

어플리케이션레벨 로드 밸런싱도 있음. HTTP프로토콜로 생각 할 수 있다. 디스패쳐에서 어플리케이션레벨까지 열어보고 내용을 봐서 적절한 서버에 넘겨준다. 이러한 방법은 각 서버가 다른 역할을 한다고 할때 적절한 서버에게 넘겨주게 된다.

#### Solution

소프트웨어적으로 로드밸런스 가능하고 하드웨어적으로도 가능하다

##### 하드웨어

보통 베이직 인티그레이티드 서킷 레벨어서 하게 되어 하드웨어를 제작하여 파는것. 알테온 스위치 같은것. 고가의 하드웨어임. 트랜스포트 레이어에서 하드웨어적으로 오픈하고 로드밸런싱하는 제품이 있다. 좀더 빠르게 처리할 수 있는 솔루션.

##### 소프트웨어

소프트웨어를 디스패쳐에 역할을 담당하도록 하는 것. 들어오는 패킷을 보고 내용에 따라 처리. 보통 어플리케이션 레이어에서 많이 함. 들어오는 프로토콜에 내용까지 열어보고 어떠한 일이 적절하게 할당되는 것이 좋은지 정하기 때문에 보통 소프트웨어 레벨. 하지만 하드웨어처럼 트랜스포트에서 할수도 있지만 빨른 알고리즘 등을 이용할때.

##### DNS

트랜스포트에서 하는 경우인데, DNS단에서 로드밸런싱. DNS서버에서 하는것처럼 디스패쳐가 DNS베이스 로드 밸런싱.안단에 있는 프라이빗한 ip를 가지고 있고 들어올때 하나씩 준다. 외부에서는 디스패쳐에게 로지컬 네임이나 버츄얼 ip어드레스를 준다. 거기중 대표 주자로 받고, 실제로 ip어드레스가 있는 서버들이 있는데, 들어오는 패킷에 따라 서버들에게 적절하게 전달. 

적절한 글로벌 서버 로드밸런스 알고리즘을 가지게 됨. 적절하게 서버들에게 로드를 전달하게 된다.

##### TCP/IP

트랜스포트 레이어에서 적절하게 운용. 많은경우 소프트웨어적으로 풀게 된다. Linux virtual server(LVS) 등 을 가지고 처리. TCP forward를 어떻게 처리할 것인지 처리 등 가능. 

#### Example

<img src="image/스크린샷 2020-04-29 오전 11.54.47.png" alt="스크린샷 2020-04-29 오전 11.54.47" style="zoom:67%;" />

로드 밸런스 예시.

<img src="image/스크린샷 2020-04-29 오전 11.56.39.png" alt="스크린샷 2020-04-29 오전 11.56.39" style="zoom:80%;" />

로드밸런스가 두개. 캐쉬 서버가 두개이다. 세션을 유지한다고 해보자. 어플리케이션과 관련된 세션을 유지할 필요가 있는데 그것을 수행하는 서버. 디비를 이용하는 경우도 있지만 이는 퍼포먼스상 문제로 캐쉬서버를 두게 됨. 어떤 경우 memcached하게 하는 경우도 존재. 

