# 아키텍처 통합 문서

## 소프트웨어 아키텍쳐

0318

### Software Architecture

분명한 목적(비지니스 골)이 존재한다. 이것을 가지고 소프트웨어 시스템을 구성하는데, 최종적 소프트웨어 시스템을 구조적으로 보여주는 중간 단계 정도의 역할이 이 소프트웨어 아키텍쳐이다. 설계하고 분석하고 다른사람이 이해할 수 있는 보고서 형식으로도 보여질 수 있어야 하고 이것을 보고 구현도 가능해야한다. 

거대한 시스템에 대해 만들때 이것은 **너무 복잡해서** 여러 **전문 분야**가 필요하게 되고 **의견이 상충**될 수도 있다. 중앙에서 통제하는 작업도 필요.

아래와같은 요소들을 고려해야 한다. 

- Scale 규모
- Cost 비용
- Schedule 일정
- Stakeholders 이해 당사자들
- Skill of dev teams 팀원들의 능력정도
- Mateials and technologies 자원들
- Risk 위험 요소
- Dev process 개발 공정
- Etc.

### Software Architecture Def

소프트 아키텍쳐라는 것은 구조적인 무리들이 있는 것이다. 구조적인 무리가 왜 필요한지 역할이 무엇인지에 대한 합리적인 결과를 가지고 구성 되어 있다. 

**그래서 시스템에서 소프트웨어 아키텍쳐이다 하는것은 시스템이 왜 필요하고 어떤 이유에서 만들것이며 엘리먼트가 하는 역할을 결정하고 관걔성을 결정하고 특성을 도출하는 것이라고 말할 수 있다.**

소프트웨어 시스템은 구조적인 형태를 가진다. 하나의 구조가 모든 아키텍쳐를 나타낼 수 없다. 시스템 전체는 하나로 표현이 불가능하다. 여러가지로 생각할 수 있다.

#### 1. 모듈

모듈은 해야하는 일들을 할당을 받는다. RNR(Role and Responsibility). 모듈들을 해야할 일들을 모듈별로 구분하여 할당을 할 수있다. 

가장 작은 단위 **<u>Class</u>** 더 나아가 커브 시스템 등으로 나타낼수.

#### 2. Dynamic Structures(동적 구조)

엘리먼트 들이 다른 엘리먼트들과 실행시간동안 어떻게 협업하고 일을 할지에 대한 것을 집중적으로 보는 것. **<u>C&C structure</u>** (컴포넌트, 커넥터)

#### 3. Mapping 

배치나 할당에 대한 것이다. 모듈을 어떤 구조체로 어느 티어에 배치할 것인지. 서버를 어떤 티어에 어떤 레이어로 둘것인지 그런것에 대한 것이다.



아키텍쳐 라는것은 시스템의 특성을 나타내야 한다. 왜 이 시스템이 구조적으로 구성되야 하는지 합리적으로 보여주는 것. 시스템에 따라 설걔하고 결정. 

특성을 표현하기 위해 우리가 어떤 식으로 설계를 하게 될까 라는 reasoning. 변경을 어떻게 가능하게 할것이냐는 고민. 구조적인 결정을 지원. 그리고 구조화가 일어나는 것이 소프트웨어 아키텍쳐이다. 

## 소프트웨어 아키텍쳐

0320

### 리뷰

비즈니스 골이 존재 구현하고자 하는 시스템이 존재하고 소프트웨어 아키텍쳐는 이 가운데에서 구조적인 설계를 제공하는 역할을 수행한다.

시스템에 있어서 이유가 도출되는 구조의 집합체. 구조라는 것은 엘리먼트가 존재하고 엘리먼트간 관계에 대해 정의할 수도 있고, 특성을 내비칠 수도 있다. 소프트웨어 시스템을 구조적으로 만드는데 있어서 왜 이렇게 설계되어야 하는지 도출하고 엘리먼트의 관계성 특성 등 도출이 가능하도록 한다.

Reasoning과 properties를 가질때 이 구조는 Architecture하다라고 할수 있다. 어트리뷰트로 잡아 이용가능하다

시스템을 바꾸려고 할 때 어려운점을 특징으로 잡을 수 있다. 

- Functionality
- availability
- difficulty
- responsiveness

### 아키텍쳐와 추상화

아키텍쳐는 매우 추상적 개념. 소프트웨어 엘리먼트가 무엇으로 이루어져 있는지, 어떤 관계를 가지는지 표현하는 것을 추상화 한다고 표현 할 수 있다. 외부에서 보는 뷰를 생각하고 내부에서는 프라이빗한 요소들을 고려해야 한다. 

abstract하다 라고 하는것은, 복잡한 시스템을 좀더 추상화 할수 있다라고 이야기 하는 것이다(?) 외부에서 보는것에 대한 interface를 def한다고 한다면 내부에 요소를 정의한다 라고 생각하면 될것 같다. 

아키텍쳐는 행동을 포함한다. 어떤 역할을 담당하고 그에 따라 역할을 수행하고 관계를 가지고 하는 것을 def할수 있다. 각 행동이 존재한다. 엘리먼트의 행동은 다른 엘리먼트에 영향을 미친다. 전체로써 영향을 미치는 정도도 고려할 수 있다. Reasoning은 이러한 행동(behavior)도 포함해야 한다. 엘리먼트가 있고 다른 엘리먼트간의 관계성을 def할 필요성이 존재하고, 해야한다. 아키텍쳐는 내부 설계를 하면서 소프트웨어의 철학적 개념 등도 포함하는 것으로 생각 해야 한다..?

### 아키텍쳐의 정의

소프트웨어 아키텍쳐란, 이 시스템을 기본적으로 갖춰야 하는 조직체 라고 정의 할 수 있다. 컴포넌트와 관련된 관계성에 대한 고려, 전반적인 구조체이고, 다른 엘리먼트와 연결되고 Reasoning에 대한 컨셉도 가지고 있고 뭐 그런것이다. 

- 목표성능 설계변수 제약조건

> 세가지를 고려하여 최적 설계안을 고려할 수 있다.
>
> 설계변수를 정의해서 무엇이 필요한지를 정의하고 목표 성능에 대해 정의하여 측정가능한 성능을 도출할 수 도 있고, 아키텍쳐를 변경할 수 없는 제약 조건들이 존재하는데 그것들(contraint)라고 표현함

단 하나의 솔루션은 없다. 여러 솔루션 도출 가능. 좋은 솔루션을 도출하는 방향으로 진행 되어야 한다. 

목표 성능치에 만족할 정도의 솔루션을 채택하여 진행.

제약조건(constraint)이 변경이 매우 어렵다면 hard, 절충 가능하다면 soft

> 시스템 자체가 구현되는 것이 아니고 문제에 대해 모델링을 수행하여 선택하고 솔루션을 진행한다.

OOP vs Structure Programing 차이점?



#### 소프트웨어 모델링 목적

시스템이 있고 모델링이 있다. 모델 = 관점(?) 각 시스템과 모델링 사이에는 이해 가능한 것들이 존재(?)

## 소프트웨어 아키텍쳐

0320

### 리뷰

타겟 시스템이 있을때 문제 자체에 대해 모델로 만드는 것이 소프트웨어 아키텍쳐의 중요한 부분. 이렇게 모델화 한것으로 솔루션을 만든다. 

대상 시스템과 모델이 하나의 공통적인 이해관계로 묶이고 기능과 품질이 나타나게 된다고 배웠다.

### 구조 & 뷰

아키텍쳐의 구성이 있을때 그것을 나타내는 것이 뷰라고 할 수 있다. stackholder의 예시 는 업무 관리자 준수 검토자 아키텍터 고객 디비 관리자 배포자 설계자 평가자 구현자 유지 보수자 등 시스템과 관련된 모두가 stackholder라고 지칭할 수 있다. 뷰는 설계의 구조를 나타낼수 있는 리프리젠테이션을 가지고 있다라고 할 수 있다. 

- Structure

  모듈(?)

- View

#### 모델링 뷰 

4+1 뷰

- Logical
- Process
- Implementation
- Deployment
- Use-Case

유스케이스뷰가 전체를 아우르는 것이다.

##### Logical viewPoint

기능적인 요구사항에 대한 뷰라고 할 수 있다. 보통 시스템이 제공하는 서비스들이 이런 기능적인 요구사항을 반영한다고 볼 수 있다. 

- 클래스 형태
- 인터랙션의 형태

로 나타낸다

##### Process Viewpoint

> Processor / process / thread 에 대해 고민.
>
> process는 실행되는 일이다. 즉 프로그램. 스레드는 큰 프로세스에 대해 나누어 실행하는 것.  

프로세스를 어떻게 관리하고 스레드를 어떻게 관리 할 것인가에 대한 것이다.

퀄리티에 따라 nonfunctional requirements로 할지 다른 것에 대해 적용할지 등 품질이나 avaiability에 대한부분.

##### Deployment viewpoint

배치에 대한것. 어떠한 서버에 어떠한 것을 넣어줄것이고, 어떠한 곳에 어떠한 것을 적재 할 것인지에 대한 것을 명세함. 

system's non functional req를 고려할 수 있다.(+system availability, reliability,performance)

##### Implementation viewpoint

모든 환경이 된 상태에서 구현이 배치 될 수 있느냐에 대함..?

##### Scenario viewpoint(Use-Case viewpoint)

시스템을 사용하는 사례(내용)에 있어서 액터가 어떤 상황에 따라서 무엇을 할지 액티비티가 나열이 되고 어떤 결과가 도출되는 것인지 나타내는 것이다.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-03-20 오전 10.12.56.png" alt="스크린샷 2020-03-20 오전 10.12.56" style="zoom:50%;" />

## 소프트웨어 아키텍쳐

### What

커스텀머의 요구사항을 반영하는 모델을 만들어 구현을 성공적으로 진행하도록 하는 것이다. **아키텍쳐 스타일과 디자인 패턴** 등을 이용하게 될 것이다.

시스템 요구사항 구체화를 통해 나타내고 분석 모델을 제공한다.

### who 

소프트웨어 아키텍트 와 디자이너 등이 아키텍팅을 한다. 아키텍트는 복잡한 구조의 시스템을 **divide and conquer**하여 구현하기 쉽도록 분할한다.

### why

poor한 디자인과 good 디자인이 있다. 

##### 좋은소프트웨어 디자인이란

당면한 어려운 문제를 설계 방법론과 설계 능력을 통해 위험도를 낮춰주는 형태를 좋은 설계라고 한다. 주어진 dev팀원들이 좀 더 체계적으로 접근할수 있도록 하는 것. 구현되고 테스트 될때 추적 가능한 형태로 하는 것이다. 소프트웨어 품질이 Higher quality attributes한 것을 의미한다.

##### poor 소프트웨어 디자인이란

시스템 요구사항을 제대로 반영하지 못하는 디자인, 새로운 기능의 추가 등 업데이트마다 완전히 시스템을 갈아 엎어야 하는 경우. 재사용이 어려운 경우. 예측할 수 없는 상황을 handle 할 수 없는 설계 가 이것에 해당한다. 

좋은 소프트웨어 디자인을 위해 아키텍쳐를 설계한다

### when

Analysis -> SRS -> Design -> SDD -> Implementation -> Testing 

- SDD  (Software Design Descriptions)
  - design overview,purpose,scope
  - decomposition description
  - dependency and connection description
  - attributes
  - User interface description
  - detailed design

- SRS(Software requirements specification)
  - Requirement Modeling
    - imformation domain modeling, data modeling
    - function modeling, behavioral modeling
    - User interface modeling
  - Requirement Descrption
    - UML
    - Data Flow Diagrams
    - State Transition Diagrams
  - Two aspects
    - Functional requirements(기능적 요구사항)
      - **The functionality of the software system**
    - Nonfunctional requirement(비 기능적 요구사항)
      - **system qualities**, constraints, and behaviors

## Architecture Design Guideline

### software architect Tasks

시스템화로 구조적인 파티션화를 고려해야 한다. 의미론적으로 분해를 해 나갈 필요성이 존재한다. 분해에 따라 서브 시스템을 나누고 그것들끼리 어떻게 연결하고 작용하게 할지에 대해 고민해야 한다. 다이나믹하게 서브시스템간의 운용 또한 고려할 사항이다. dynamic control relationships. Tradeoff analysis on quality attributes and nonfunctional requirements

### Architecture style

특징적인 일을 추상화 시켜 구조적으로 솔루션을 제공하는 것이다. 예를들어 다른 종류에 것에 대해 솔루션을 제공한다면 레이어를 나우어 서브 시스템을 제공하는 형태 등을 취한다. 다이나믹한 내부 처리 로직 등 구조적으로 많은 것을 반영하여 작성해야 한다.

### Key components of an architecture style

- Elements

  각 시스템에서 정의된 기능을 가지고 있는 요소.

- connectors

  다른 종류의 엘리먼트를 연결하는 것.

- Contraints

  제약사항. 엘리먼트가 다른 형태로 연동이 될 때 고민해야하는 여러가지 요소들.

- attributes

  속성. 구조적인 장점과 단점을 표현 할 수 있다. 아키텍쳐 스타일의 장점이 있는데, 이 스타일을 고르는데 고려하고, 문제를 야기할 수 있는 것을 포함한다.

### 가이드라인

1. 무엇을 할까(what to do)에 집중한다. -> identified, verified, validated 

2. Concrete design에 앞서 abstract design을 먼저 도출한다. 

3. 비 기능적 요구사항을 비교적 일찍 고민하는것이 좋다. 

4. 가능하면 재사용성, 확장성(extensibility)을 고려하여 디자인한다.

   OO디자인을 고려하며 이용한다.extensibility는 다양한 것을 붙이는 형태 scalability는 더 확장을 해 나가는 형태.

   안정성이 높아진다. 

5. High cohesion & loose coupling

   할일이 그곳에 있는 정도. 한곳에 할 일이 너무 많으면 목적이 불 분명하고 처리 능력이 떨어진다. 필요한 일만 넣는다. 

   커플링은 서로관의 너무 결합도가 높은 것을 의미한다. 서로 분리가 될 수 있게 하는 것이 좋다.

6. Tolerate refinement of design 

   개선 가능성이 존재한다.

7. Avoid ambiguos design and over-detailed design

### Models for software architecture

전체 모델은 일반화된 형태에 대한 구조를 가지고 필요에 따라 분해한 형태를 가지고 이것을 결합해 이용하며 architecture style, quality attribute를 고려함.

##### Software architecture

- describe its collection of components and the connections
- interactions among these components
- specify the deployment configuration of all components and connections
- conform to the projects finctional and nonfunctional requirements

### Way to describe software architecture

UML을 이용하여 표현할 수 있다. 4+1 view model을 이용할 수 있다. 

- 4+1 

  logical ,process, delopment, physical, user interface

  

## Quality Attribute

### 품질

소프트웨어 시스템을 만들 때 시스템이 필요로 하는 필요성을 만족 하는 정도가 품질의 정도이다. 제품과 서비스의 품질이 만족하는 정도가 품질의 정도

### 품질 속성

양이나 질로 관찰하여 수치로 측정할 수 있는 시스템의 특성

- 품질 속성은 이해관계자들의 관심사와 요구사항을 그대로 반영한다.
- 아키텍처는 이해관계자들이 원하는 수준으로 품질속성을 달성해야한다. 

시스템의 주요한 기능중 하나. 성능이나 보안 등. 비 기능적 요구사항을 반영하는 중요한 부분. 이해 당사자가 원하는 품질에 대한 것을 반영하여 품질 속성을 뽑아내는 것이다. 

얼마나 이해 당사자가 원하는 비 기능적 사항을 반영했으면 좋겠습니까 ? 하는것을 아키텍트가 파악하여 설정하는 것이다. 

### 구현에서의 품질 속성

- 연동가능성(interoperability)

- 확장 가능성(Maintainability and extensibility)

  부분적 변경이 가능 하도록, 또는 추후 기능 추가가 가능하도록

- Testabiliry

  테스트 가능의 정도

- Portability

  이식 가능성. 소프트웨어가 다른 시스템에 이식 할때 작동의 가능성을 나타낸 것이다.

- Scalability

  홪장 가능성. 위의 확장과는 조금 다른데 규모의 경제와 관련된 것이다. 유저의 요청에 따라 얼마나 반응 할 수 있는지(?)

- Flexibility

  변경을 함에 있어서 유동적으로 할 수 있는 정도. 요구사항의 변경에 대해 얼마나 유연하게 대처 할 수 있는지. 

### 런타임 품질 속성

- Availability

  항시 구동 되는 정도

- Security

  보안의 정도

- Performance

  성능. 시스템이 효율성을 가지고 처리할 수 있는 정도. 시간과 자원

- Usability

  사용자가 이용 가능성 

- Reliability

  죽지 않을 가능성 실패의 정도가 적다. 실패가 발생해도 적절히 처리하는 정도

- Maintainability(extensibility,adaptability,serviceability,testability,compatibility,and configurability)

  유지 가능성

### 비지니스 속성

- Time to market

  시장성을 위해 특정 시간 내로 시장에 내보내야 하는 정도

- Cost

  비용

- Lifetime

  더이상 필요 없을 정도까지 얼마나 이 시스템을 사용 할 수 있는지에 대한 정도



신뢰와 성능의 tradeoff

Scalability와 성능간의 tradeoff

어떤 것을 우선할지 잘 선택해야 한다. 

## 소프트웨어 아키텍쳐

7강

### Quality

Product or a service 가 필요적으로 만족하는 feature와 characteristic의 정도로 나타나는 것이 Quality

### 표준

ISO/IEC FCD 25010 : SQuaRE 최근에 이것으로 변경. 본래는 ISO/IEC 9126 어떤 표준을 따라야 한다는 것은없음. 필요에 따라 따를것.

### 품질 모델

#### 품질모델구조(IEEE 1061)

##### Quality

목표 시스템이 충족해야 할 품질

##### Quality Factor

사용자나 관리자 중심, 시스템이 외부에 보이는 품질,Charactoristics,Factors라고도 한다.

##### Quality Subfactor

구현자 중심, 시스템 내부에서 다루는 품질. Quality Factor를 측정할 수 있는 소프트웨어 속성으로 바꾼것. Sub-characteristics,Criteria라고도 한다.

##### Metric

평가자 중심. 품질을 측적하는 방법과 척도

#### 구조 적용 예

예를들어 효율성 이라고 한다면 내부에 Time behavior라던가 Resource관련 요소가 나올 것이다. 

### ISO/IEC 9126 품질 모델

외부와 내부로 분리. 외부와 내부에 대해 각각 6개의 특징들을 명시한다. 각 특징들은 부 특성들로 나누어진다. 각 특성들을 내부와 외부 metrics에 의해 측정된다.

라이프사이클에서 품질 측정을 많이 하게 된다. 

#### Quality in the lifecycle

좋은 소프트웨어 시스템을 가진다는 것은 내부적 퀄리티를 만족하는 것이고, 내부 퀄리틸가 좋은 것은 외부 퀄리티가 만족한다는 것이고 외부 퀄리티가 좋다면 사용자 입장에서 사용에 대한 퀄리티가 만족한다는 것이다.

- Functionality

  필요한 기능을 제공하는가

  - Suitability
  - Accurateness
  - Interoperability
  - Compliance
  - Security

- Reliability

  믿을만 한가

  - Maturity
  - Fault Tolerance
  - Recoverability

- Usability

  쓰기 쉬운가

  - Understandability
  - Learnability
  - Operability

- Efficiency

  효율성은 좋은가

  - Time Behavior
  - Resource Behavior

- Maintainability

  유지보수 가능한가

  - Analyzability
  - Changeability
  - Stability
  - Testability

- Portability

  이식 가능한가

  - Adaptability
  - installability
  - Conformance
  - Replaceability

### Quality Model (ISO 25010)

#### Functional Suitability

- Functional Completeness

  기능적으로 완성을 했느냐 

- Functional correctness

  정확한가

- Functional appropriateness

  적절한가

#### Performance efficiency

- Time Behavior

  Due time

- Resource Utilization

  자원의 효율성 (CPU, RAM, Network,Storage,VM 등)

- Capacity

  예를들면 어떤 시스템에서 다른 시스템에 스트리밍을 준다고 할때 큐를 어느정도 할 것이냐 버퍼가 충분한 용량을 가지지 않으면 지터가 발생. 

#### Compatibility

호환정도

- Co-existense

  여러시스템이 같이 공존하는 정도 

- Interoperability

  다른 시스템간 상호 호환정도

#### Usability

- Appropriateness
- Learnability
- Operability
- User error protection
- User interface aesthetics
- Accessibility

#### Reliability

신뢰

- Maturity

- **Availability(중요)**

- Fault tolerance

  장애 극복

- Recoverability

  회복성

#### Security

- confidentiality

  기밀한 내용을 권리가 있는 사람이 적법하게 접근하는 정도

- integrity

  데이터가 있으면 그 데이터가 안전하게 저장 되는 정도

- Non-requdiation

  액션을 했을때 차후에 부인을 하지 못하도록 하는것

- Accountability

  추적을 할 때 책임을 충분히 지는 형태

- Authenticity

  진위 파악의 정도

#### Maintainability

- Modularity

  모듈화 정도

- Reusability

  재사용 정도

- Analyzability

  분석화 정도

- **Modifiability**

  **수정 가능의 정도**

- Testability

  테스트 가능의 정도

#### Portability

이식 가능성

- Adaptability
- installability
- Replaceability

#### 품질모델 (ISO/IEC9126)

- Quality in use
  - Effectiveness
  - Productivity
  - safety
  - Satisfaction

## 소프트웨어아키텍쳐

### Class Diagram

설계시 가장 많이 사용되며 그 모델링 개념의 폭이 넓음.

#### 4가지 표현법

- 이름만 표기
- 이름 + 속성(Attribute)
- 이름 + operation
- 이름 + 속성 + operation

#### 기술방법

- Visibility

  - '+' : public
  - '#' :protected
  - '-' : private

- 변수 기술 방법

  Name:type

- 함수 기술 방법

  visibilityIndcator name(formalParameters)returnType

만일 클래스명이 기울어져 있다면 abstract class. 

### Boundary class

초기에는 액터/유스케이스 한 쌍  히나의 바운더리 클래스를 설정해도 좋다. 이후 여러개의 바운더리 클래스 또는 컨트롤 클래스로 분할 될 수 있다.

바운더리 클래스는 사용자 , 외부시스템, 장비 등과 상호 작용하는 클래스이다.

외부의 일과 연결되는 클래스들을 바운더리 클래스라고 정의한다. 

### 엔티티 클래스

도메인의 컨셉을 가지고 있는 클래스. 시스템 관점에서의 주요 추상 개념이다.

유스케이스 기술서의 사건흐름으로부터 파악한다. 주요 추성개념을 참조한다. 관련 지료들로부터 명사를 선별하고, 이로부터 엔터티 클래스를 찾아낸다.

### 컨트롤 클래스

유스케이스 행위를 조정하는 클래스. 한 유스케이스에 한 컨트롤 클래스.

### 상위 클래스 다이어그램

관련 클래스들의 적절한 분류(classification). 업무 분류는 클래스 다이어그램에 패키지를 통해서 표현. 관련 있는것끼리 하나의 패키지로써 묶어 이용.

## 소프트웨어 아키텍쳐

### Sequence Diagram

동적인 Object와 관련된 서로의 인터렉션들을 표현하는 다이어그램. 시스템이 실행되고 나서 객체들이 실생되는 순서나 메세지 들을 볼 수 있는 장점. 

이벤트에 따라 시간 순서대로 어떤 일이 일어나는지 볼 수 있는 장점.

액터가 이 시스템과 더불어 하는 일을 순서대로 볼 수 있다. 

이벤트, 시그널, 메세지를 통해 이루어짐. 

#### Nested Messages

메세지를 받으면 NestedMessages를 보내고 결과를 받고 후에 결과론적으로 받은 메세지에 대한 결과를 돌려준다. 

### Communication Diagram

UML 1.X 버젼에서는 Collaboration Diagram이라고 불림. 객체와 객체간의 인터렉션을 보여준다. 메세지로 상호간의 전달되는 메세지를 보여줌. 시퀀스와는 다르게 순서대로가 아닌 메세지에 일련번호를 부여하여 파악한다. 

구조적으로 어떻게 되었는지 파악하기에 용이하다. 

#### Vs Sequence

참여하는 것에 대해 좀 더 커뮤니티가 구조적으로 볼 수 있다. 링크가 더 자세히 보인다. 

## 소프트웨어 아키텍쳐

### 가시성(visibility)

- Private scope : 클래스안에서만
- package scope : 같은 패키지 안에서만
- Protected scope : 상속받는 관계에서만(같은패키지 가능)
- public scope : 시스템 전체에서

### 속성

어트리뷰트라는 것은 정보를 담을 수 있는 곳. 속성 또는 연관관계로 표현

> [Visibility] [/] name [:type] [multiplicity] \[=default][{property-string}]

> Static Attribute는 밑줄을 쳐서 구분한다.
>
> 속성이 한 class의 여러 객체에 의해 공유된다.

### 연관관계

연관관계는 소스 class와 타겟 class를 연결. 속성의 이름은 역할이름으로 표현. 연관관계의 양 끝에 개수를 표현

### 메소드

행위에 대한 명세.

> [visibility] name [parameter-list] ':' [return-result] [{properties}]

#### 정적 메소드

동일하게 밑줄 그어 표현. 이때 인스턴스가 아니라 정적 메소드임에 주의(인스턴스 선언부분에서)

### 관계

클래스간의 관계를 어떻게 표현 할 것이냐에 대한 것이다.의존,연관,집합,복합,상속 5가지가 있다.<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-01 오전 10.26.36.png" alt="스크린샷 2020-04-01 오전 10.26.36" style="zoom:80%;" />

### 의존성 관계

서로 아는 정도. 한 요소가 다른 요소에 의존도 정도. 의존성을 통제하지 못할 경우, 통제가 어려워진다. 

### 연관관계

주로 컴포지트한 클래스가 다른 클래스에 전가되서 갈 수 있도록 할때. 어떤 의미로 연관되어 가는지 표현. 단순 일직선인 경우 서로 연관. 화살표 방향이 있다면 화살표 방향으로 의존. 

### 집합관계(aggregation)

하나에 해당되는 것이 여러개에 관련. 예를들어 '장'이라는 것은 '책'이라는 것의 부분. Association이 큰의미 그안에 Aggregation. 그안에 Composition.

> 클럽에 멤버들이 있다. 큰 측에 다이아몬드가 그려진다. 

### 구성 관계

Composition은 전체-부분관계. has a, contains,is part of 등과 같은 말로 표현. Aggregated instances <u>must belong to only one composite at a time</u>

Composition은 물리적인 결합되어 있어 분리되어 생각 불가능. 계층 구조를 가질 수 있다. 채워진 다이아몬드로 표현.

### 상속 관계

수퍼클래스와 서브클래스간 놀리적 추상화 제공.

### 추상 Class

직접 인스턴스를 생성할 수 없는 클래스. 보통 이탤릭체로 표현한다. 

### Interface

구현을 가지지 않는 Class. 모든 특성이 추상화 되어있음. \<\<interface>>로 표현한다. 구현의 변경이 용이. 변경에 의해 영향 받는 부분을 최소화.

인터페이스를 롤리팝으로 표현 가능하다. 

### Constraints

![스크린샷 2020-04-01 오전 10.52.42](/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-01 오전 10.52.42.png)메모장 등으로 써도 가능하다.

## 아키텍쳐-GRASP

### GRASP

**가장 키워드는 <u>Responsibility</u>. Responsibility를 Assignment해주는 일반적인 패턴을 GRASP라고 한다.** 모듈에 할일을 할당해주는 일반화된 원칙을 GRASP라고 지칭 할 수 있다. OO design 원칙에 기반을 두고 있다. 

클래스의 할 일(책임)을 결정해주는 것. 전체 해야 할 일중 어떤일이 어떤 객체에서 이루어져야 하고 어떻게 할당 할지. 다른 객체와 관련되어 일을 하는 것 등. 일을 할당 받은 객체는 전반적인 설계가 어떤것이다 라고 이루어지는것이 책임을 부여한다라고 함.

##### Responsibility

Contract or obligation이라 칭함. 보통 이러한 책임은 메소드를 통해 표현된다. 해야하는 일들이 메소드를 통해 오퍼레이션 되도록 함. 혼자 작업이 될 수도 있고, 다른 객체의 메소드를 콜해서 이용할 수도있다.

두가지 일이 있다.

- 해야할 일을 하는 (Doing)

  메소드를 통해 어떤 일을 오퍼레이션 할수 있다. 다른 객체를 실행 할수 있도록. 다른 오브젝트의 컨트롤이나 제어를 시행하는 것

- 해야할 일을 아는(knowing)

  캡슐화된 중요한 데이터에 대해 알고있다. 관련된 다른 객체를 알고있다. 이 이후에 작업될 여러 일들을 알고있다. 이 이후에 변경될 정보들에 대해 아는것도 이 카테고리에 들어감.

#### GRASP

1. Low coupling
2. High cohesion
3. Expert
4. Creator
5. Controller
6. Don't talk to Stranger

##### Low Coupling

커플링의 정의부터. 커플링은 한 클래스가 다른 클래스에 연결된 정도이다. 다른클래스는 아는 정도. 의존의 정도가 어느정도 강하느냐를 커플링이라고 한다. 연결된 정도가 낮다를 low coupling이라고 한다.

커플링이 높다는 것은 어떤 내용을 변경하고 싶을때 관련된 클래스가 너무 많아서 전부 바꿔야 한다는 의미. 어떤 작은 문제를 바꾸기 위해 많은것을 변경해야함. 재사용이 어려움. 변경에 취약함

책임을 주되 가급적 의존성을 낮추고 재사용성을 늘리는 것이 로우 커플링의 핵심

##### high cohesion

응집도가 높다. 그 클래스에서 하는 일이 관련되고 집중된 정도가 어느정도 강한지를 측정함. 한 클래스에서 해야할 일이 그 일에 관련되게만 응집되도록 하는것을 의미한다. 이것저것 다 하게 하는것은 좋지 않다는 것. 보통 스파게티 코드같은 것을 보면 한 클래스에서 이것저것 다 해서 보기 힘든데 그것이 이것이다. 

낮은 응집도를 가진다면 관련 없는것들이 너무 많다. 일들을 위해 에너지가 낭비되고, 이해가 어렵고, 변경이 어렵고 수정도 어렵다. 하이 커플링도 낳는 악영향이 있다.

해야 할일이 집중되서 있는 형태가 가장 바람직 하다. 이렇게 응집도가 높은 설계는 복잡합 일들을 관리하기 편하게 한다.

엘리먼트가 혹은 클래스가 왜 존재해야 하는지를 눈으로 쉽게 인식 할 수있다.  코드도 재사용 하기 쉽고 커플링도 낮아지는 효과를 볼 수 있다.  



![스크린샷 2020-04-06 오후 11.32.20](/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-06 오후 11.32.20.png)

##### Expert

전문가 라는 것인데, 전문가의 특징은? 그일을 아주 잘 아는 사람. Information Expert라고도 한다. 그 일에 대해서 잘 알고있는 역할을 가진 모듈을 그 일을 담당 하도록 하는것이 Expert를 만드는 설계가 할일..? 그 일을 수행하기에 적절한 모든 정보를 가진 클래스가 Information Expert라고 할 수 있다. 

전반적으로 클래스는 필요한 정보만 가지도록 하는것이 중요하다. 

정보가 있는 곳에서 일이 처리하도록 하는것이다. 정보가 다른곳에 돌아다니도록 하지 않는것이 중요핵심. 데이터가 로컬되도록 하는 것이 주된 내용.

정보에 관련되어 인캡슐레이션. 필요한 정보가 그 위치에 있도록 하여 커플링이 낮아진다. 외부에서 메소드를 불러 그 정보를 처리하도록 한다. Robust,maintainable하도록함.

behavior가 필요에 따라 정당한 위치에 있도록. 하이 코헤젼

##### Creator

컨스트럭터와 구별되야 한다. 컨스트럭터는 클래스를 만들고 그 객체를 생성 하도록 하는 컨스트럭터를 말하는 것이고 크리에이터는 관련된 객체에 대해 누가 그 객체를 생성하느냐를 결정 하는 것이다. 

예를들어 클래스 B가 있고 A가 있는데 B야 A의 인스턴스를 만들어 주겠니 ? 하는 것이다. 

- B aggregates A
- B contains A
- B records instance of A
- B closely uses A
- A가 이용하는 어트리뷰트를 B가 가지고 있을 때

##### Controller

제어. 외부에 일들이 일어나고 내부에 그 일들을 처리하는 경우가 있다. 내부의 일과 외부의 일을 분리하는 것을 컨트롤러가 한다. Indirect coupling하도록 함.

외부에서 이벤트가 일어나면 컨트롤러한테 보낸다. 이 컨트롤러는 이벤트 내용을 보고 핸들러를 불러준다. 제어자는 외부의 일과 내부의 일을 컨트롤러 기준으로 구분되게 설계 하도록 함. 

외부의 일을 받아서 적절한 내부에게 forwarding함. 

facade controller. Use case 역할이나 전체 비지니스의 organization 역할 role controller(역할을 담당하는 컨트롤러) 

##### Don't talk to strangers

어떤 두 클래스가 있는데 두 클래스는 다이렉트하게 연결될 필요가 없음. 다이렉트하게 연결하지 말아라. 레퍼런스를 연결해주지 말라는 의미. 

정보만 교환하는 경우 인다이렉트하게 정보만 넘겨줄 수 있는 클래스를 하나 만들것. 직접 연결 된 경우 필요 이상의 데이터를 모두 이용 가능할 수 있게 됌. 

Intermediate unit이 생김. (중재) 관련 없는 클래스가 연결되려 할때 이런 중재 유닛을 두고 관리해야 한다.

커플링 낮아짐. 

## 아키텍쳐

### 계층적인 소프트웨어 아키텍쳐

전체 시스템을 계층적인 구조 형태로 구분하여 보는 형태. 전체 시스템을 구성할때 어떤식으로 할지 막막할 때가 있는데, 그럴때 로지컬 모델이 어떤 것이 있는지 먼저 생각해서 그것을 계층적으로 레벨을 만들어 서브시스템을 구성하는것이 좋다. 

모듈들은 서로간 연결되어있고 서로 커뮤니케이션한다. 전반적 메인 모듈이 있고 그에따라 서브 모듈을 불러 나가는 형태를 취할 것이다. 마치 트리 형태.

#### 종류

- Master-slave
- Layered
- Virtual machine & Container
- Plug-In & Microkernel

### Master-Slave Architecture Style

시스템이 여러개를 제공을 하고있고 그에따라 문제가 일어날때 장애를 극복하는 형태. 이것에 따라 시스템의 신뢰도가 높아가는 구조. 마스터(주체모듈)의 역할이 있고 슬레이브(종속된 일처리를 하는 모듈)의 역할이 나누어짐. 

슬레이브는 복제되는 서비스류를 제공한다. 마스터가 어떤 주체적인 일을 한다면 슬레이브는 일을 받아서 처리하는..? 마스터는 적절한 일을 주고 받는 역할. 

#### 두 형태

- 일을 받아서 각 슬레이브에게 넘겨줌. (작은일들)
- 일을 쪼개서 각 슬레이브에게 넘겨줌. (큰일)

슬레이브는 같은 기능적인 태스크를 하기도 한다. 동종의 일을 할 수 있다는 의미이다. 마스터 하위의 슬레이브를 거쳐 일을 처리하는데 비슷한 일을 주고 비슷하게 처리해서 결과를 얻는것을 여러 슬레이브를 시킬 수 있다는 의미.  또는 하나의 큰 일에 대해 서브 태스크로 쪼갠 뒤에 각 슬레이브에게 서브 태스크를 넘겨 일을 처리하도록 시키는 방법도 존재한다. 

#### 구조

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-08 오전 10.25.41.png" alt="스크린샷 2020-04-08 오전 10.25.41" style="zoom:50%;" />

#### 예시

1. Cluster Computing

2. Case System Layout

3. Case Study : Hadoop Platform

   - Hadoop HDFS : 하드디스크 파일 시스템

     네임노드는 마스터, 데이터 노드는 슬레이브. 또는 잡트래커가 마스터, 태스크 트래커가 슬레이브. 

   - Hadoop 2.0 YARN

     YARN : Cluster Resource Management

   - Spark@Haddop 2.0 YARN

     클러스터 매니저인 YARN이 존재하고 하위에 일처리를 하는 Task들이 있다. 

#### 정리

슬레이브들이 동정의 일들을 하게 되어 병렬적으로 컴퓨팅을 하게 됌. 동일한 일을 한다면 처리하는 일중 가장 베스트한 것을 선택 할 수 도있다. 모든 슬레이브는 병렬적으로 일을 한다. 단, 다른 데이터로 하기 때문에 parallel이다. 어떤 태스크가 원하는 대로 분리가 되어 처리가 되도록 할 수 있다. 만일 적절하지 않은 결과를 내는 슬레이브가 있다면 Role out하게 할 수도 있다. 

서버들에 redundancy. 

## Case Study: Hadoop Platoform

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-08 오후 3.30.14.png" alt="스크린샷 2020-04-08 오후 3.30.14" style="zoom:50%;" />

Master - Slave구조. 

### Hadoop Distributed File System(HDFS)

분산적으로 데이터를 저장하는 구조체를 가진다. 네임 노드는 파일 시스템관련 메타 데이터를 관리하고 데이터 노드는 actual data를 관리한다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-08 오후 3.32.27.png" alt="스크린샷 2020-04-08 오후 3.32.27" style="zoom:50%;" />

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-08 오후 3.36.46.png" alt="스크린샷 2020-04-08 오후 3.36.46" style="zoom:67%;" />

### MapReduce

소프트웨어적으로 우리가 어떤 어플리케이션을 쉽게 운용할 수 있도록 프레임워크를 제공한다. 데이터를 처리하기 쉽게 하도록 하는 것. 

#### Framwork

- Resource Manager
- nodeManager
- MRAppMaster

#### Mechanism 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-08 오후 3.39.24.png" alt="스크린샷 2020-04-08 오후 3.39.24" style="zoom:50%;" />

빅데이터로 쪼갠 데이터를 나누고 맵핑을 시킨다. 그리고 처리를 하고 합쳐나가는 리듀스 작업을 수행한다. 그러면 원하는 데이터가 나오게 된다. 

### YARN

2.0으로 업데이트 되면서 YARN이라는 Resource Management하는 레이어를 추가함. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-08 오후 3.44.47.png" alt="스크린샷 2020-04-08 오후 3.44.47" style="zoom:67%;" />

## 아키텍쳐

### Apache Hadoop YARN(Yet Another Resource Negotiator)

리소스에 해야하는 역할을 좀더 분할하여 관리. 잡스케줄, 잡 모니터링을 daemons를 통해 관리한다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-10 오전 10.44.08.png" alt="스크린샷 2020-04-10 오전 10.44.08" style="zoom:67%;" />

#### YARN Managers

NodeManager, ResourceManager는 YARN에서 컴퓨팅 프레임워크에 속한다. 리소스 매니저는 전반적인 관리를. 노드매니저는 머신마다 있는 프레임워크 에이전트. 컨테이너를 관리차원에서 가지고 있고 자원을 모니터링한다. 어플리케이션을 라이브러리의 형태. 리소스 관리를 하고 노드 매니저와 협업한다. 

##### YARN Architecture

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-10 오전 10.48.12.png" alt="스크린샷 2020-04-10 오전 10.48.12" style="zoom:67%;" />

##### Resource Manager

daemon으로 작동. 전체 클러스터를 매니지먼트

##### Node Manager

슬레이브 노드에서의 daemon형태. 태스크를 실행할때 관리해준다. 데이터 노드 형태

##### Application Master

유저가 잡을 리퀘스트 하면 거기와 관련된일을 매니지먼트. 리소르를 담당하게 됌. 노드 매니저와 협업해 관리

##### Container

리소스의 패키지. 싱글 노드에서의 여러 자원을 패키지화

#### Application Submission in YARN

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-10 오전 10.51.17.png" alt="스크린샷 2020-04-10 오전 10.51.17" style="zoom:67%;" />

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-10 오전 10.53.27.png" alt="스크린샷 2020-04-10 오전 10.53.27" style="zoom:67%;" />

### 과제

퀴즈 공지 나갈것임. 팀플 아님 주의. 변경 가능성과 재사용성을 고려하여 UML Class Diagram을 작성하는 것이다. 비기능 요구사항도 넣어야 한다. 지난번 세가지는 그대로 거기에 세가지 추가. 

차고문 통신과 가정 자동화 시스템의 커뮤니 케이션과 연결되어야 하는데 형태는 다르고 

0.1초 라는 것이 어떠한 곳에서는 반드시 사용해야 하며, 그것을 메모로 명시해야 한다. 

## 아키텍쳐

### Layered Architecture Style

모든 클래스, 관련된 컴포넌트들을 하나의 레이어에 만들어 놓는것을 말한다. 전체 시스템을 레이어로 분리. 각 레이어별로 관련된 클래스들만 둘 수 있도록 한 것. 

전체 시스템을 레이어로 나눈다. 각 레이어에 관련된 클래스들을 두고 레이어가 연결 되게끔 설계한다. 이러한 스타일은 패키지, 디렉토리 구조안에 인캡슐레이션 된다고 보면 된다. 때때로 디플로이된 컴포넌트에 들어가기도 한다. 다른 프로젝트에 적재 되고 불러서 사용한다. 

#### 구조

i번째 레이어가 있다고 한다면 i+1 번째로 req보낸다고 한다면 (주로 api로 구성) 컨트롤러가 처리 한다던가 하는 구조. 인터페이스를 통해서 요청이 된다고 생각하면 된다. 각 레이어별로 캡슐화. 외부에서 내부 볼수 없음. api만 제공한다. 

주로 상단레이어에서 하단 레이어로 req보낸다. res는 상단으로 올라감.

#### OSI 7-Layer (예시)

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-11 오후 11.38.03.png" alt="스크린샷 2020-04-11 오후 11.38.03" style="zoom:50%;" />

각 레이어가 하는일을 레이어 내부에서 모두 처리되며 레이어 상단에서 하단으로 처리. 

##### Latered approach

전체 시스템으로 처리하는 것보다 레이어로 나누어 처리하는 것이 더 효율적. 팀별로 개발할때, 팀별로 점진적으로 개발할 때, 점차 증진되는 기능의 추가에서 테스트까지 수행하며 구현할때 유용하다.

#### Layered Architecture

각 레이어는 특별한 아레나를 가지고 있다. 그 레이어를 자세하게 내부 구현 볼 필요 없이 추상화 형태로 인터페이스만 뽕아서 보여주는게 좋다.

서로 관련된 것만 고려하고 나머지는 배제하는 형태를 취한다.

***"isolation concept"***

필요에따라 드라이버를 변경할때 해당 레이어만 변경하면 되므로 유연하게 대처도 가능하다.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-11 오후 11.45.24.png" alt="스크린샷 2020-04-11 오후 11.45.24" style="zoom:50%;" />

#### 스타일

일반적으로 adjacent. 하위 레이어 및 상단 레이어와 연결된 구조로 동작. 그러나 건너뛰는 경우도 존재. 이럴때는 bridge type connection를 이용하는데 이는 권장이 아님.

높은 레이어로 갈수록 좀더 일반적이로 application에 가까운, 클라이언트에 가까운 기능을 제공하고 밑으로 내려갈 수록 유틸리티나 세부적인 서비스를 제공한다고 볼 수 있다. 

넘버링은 하지 않는것이 좋다. 차후 레이어가 더 쪼개질 경우 변경 가능성에 의함. 

#### 구현

레이어는 어떤 경우에 deploy를 고려하여 구분하게 된다. 자바는 jar를 두고 다른 서버에 deploy할수 있는데, 관련 클래스 등을 전부 동봉 할 수 있다. 이런 패키지화 된 compressed한 파일은 deployed할수 있고, 클래스패스 등 환경을 신경쓰면 이용 가능하게 된다. 

#### 2 레이어

만일 레이어를 2개로 나눈다면 상단은 유저와 소통하게 되는 레이어, 하단은 처리를 하게되는 서비스를 제공하는 레이어가 될수 있겠다. (비지니스 로직이나 디비접근 등)

#### 어플리케이션 도메인

레이어 아키텍쳐는 유저가 일반화해서 쓸수 있는 어플리케이션 도메인에서 많이 사용하고 있다. 일반화 서비스를 위해 많이 이용. 레이어로 잘라서 일처리. 패키지별로 관련된 클래스가 같이 개발될수 있게 하고 때론 적재될 수 있도록 한다. 

#### 장점

소프트웨어 개발할때 점진적으로 완성을 하는 구조에 아주 적합한 아키텍쳐. 레이어를 무엇으로 구분할지 정하고 레이어를 하나씩 개발해 외부에 추상화로 제공한다. 레이어마다 독립성을 제공하고, 변경 가능성을 제공하고 있다. 그래서 유연하다. 재사용성 등 높음. 컴포넌트 베이스로 잡으려면 이러한 아키텍쳐 형태가 좋다. 플러그앤플레이 형태로 컴포넌트 제공가능. 코드가 다른 시스템에 이식이 쉽다. promotion of portability

#### 단점

가장 큰 문제는 퍼포먼스에서의 문제이다. 레이어를 거쳐서 일이 내부적으로 어떻게 처리되는지 모르면서 작업 요청만 하기 때문에 performance concerns of overhead 발생할 수도. 

통상 data marshaling and buffering에서 많이 먹음. 

레이어가 건너뛰는 경우, 데드락이 발생할 수 있음에 주의. 

예외처리와 핸들링의 경우. 레이어 안에서는 레이어 안에서 처리하게 됨이 옳다. 모르는 예외라고 자꾸 넘기게 되면 처리가 불가능하게 될 수도있다. 

## 아키텍쳐

### Virtual Machine

가상 머신. 존재하는 시스템에서 그 위에서 올라가는 시스템. 존재하는 시스템은 피지컬 머신. 하드웨어와 OS환경 등. 이 위에 가상 환경이 올라간다. 실제로 피지컬과 구분하는 가상적인 공간. 그 공간을 virtual abstraction 혹은 그 위에서 작동하는 특성과 operation이라고 볼 수 있다. 

피지컬 머신과 분리하여 그 환경에서 돌아가는 프로그램 랭귀지나 환경을 제공한다. 하여간 피지컬과 분리. 이것은 때론 이뮬레이션 환경이라고 하기도 한다. 

#### 예시

머신에서 커널만 있으면 그 위에서 쉘 커맨드를 할 수있다. 또다른 예는 .net 프레임 워크에서 Common Lamguage Runtime. 다른 언어로 작성되었어도 동일 환경에서 적용 가능

JVM. 자바 바이트 코드는 어떠한 환경이던지 JVM만 있으면 실행 가능. 

#### JVM

아주 기본적인 엔진 구조 예시. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-13 오후 11.04.38.png" alt="스크린샷 2020-04-13 오후 11.04.38" style="zoom:67%;" />

OS 위에 운영되는 엔진을 올려 놓는다. JVM이 바이트 코드를 읽고, 오퍼레이션을 운용. OS와 엔진간 분리가 되어있음. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-13 오후 11.05.50.png" alt="스크린샷 2020-04-13 오후 11.05.50" style="zoom:67%;" />

JVM을 깔면 어떠한 피지컬 플랫폼이던지 바이트 코드에 대한 것을 실행 가능 하다. 

#### Application

JVM은 피지컬적인 상황과 전혀 관련 없는 문제 해결을 할때 좋다. 예를 들어 데스크탑에서 핸드폰에 올라가는 어플을 개발한다면, 데스크탑의 환경과 스마트폰은 다른데, 동일한 환경을 위해 이뮬레이터를 만들고 스마트폰에서 돌아가는 프로그램을 만드는 것이다. 

그 안단에 인터프리터가 존재한다. 이것을 이용하여 피지컬의 리소스를 이용하여 가상 작동..?

#### Cloud Computing

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-13 오후 11.09.50.png" alt="스크린샷 2020-04-13 오후 11.09.50" style="zoom:67%;" />

베어한 컴퓨터와 가상 머신을 이용하는 시스템을 비교. 일반적 머신은 하드웨어가 있고 OS가 있다. 그위에 여러가지 어플리케이션 라이브러리와 프로그램이 존재. VM은 하드웨어 위에 OS위에 하이퍼바이저가 있다. 하이퍼바이저는 피지컬 오퍼레이팅 시스템을 다른 VM에서 공용적으로 사용할 수 있도록 하는 것을 제공. 하이퍼바이저 위에 새로운 OS 올라가고 그위에 라이브러리 / 프로그램이 있는 것이다. 이 OS는 피지컬 OS와 전혀 관련 없어도 된다. 

하이퍼바이저는 역할은 제한된 리소스를 여러 VM들이 공유할 수 있도록 해주는데 도움을 준다. 예를들어 IO에서 인풋 아웃풋에 대한 것은 피지컬 OS를 통해서만 제공하는데, 이것을 하이퍼바이저가 매핑을 시켜주는 등의 역할을 하고 네트워크 또한 이용 할 수 있도록 한다. 

가운데 있는 컨테인은 하이퍼바이저 대신 컨테인엔진이 있다. VM에 OS가 없다, 대신 라이브러리나 디렉토리의 형태로 가진다. 이러한 구조는 OS를 운용을 하지 않음. 이런 형태는 하이퍼 바이저보다 OS를 차지하는 공간이 적기 때문에 매우 효율적으로 이용가능하다. 

#### Android Platform

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-13 오후 11.16.06.png" alt="스크린샷 2020-04-13 오후 11.16.06" style="zoom:67%;" />

안드로이드 런타임만 본다면 VM이라고 볼 수 있다. 안드로이드 플랫폼은 레이어 아키텍쳐와 VM둘다 나타난다고 볼 수 있다.

##### Orale VM VirtualBox 

#### 장점

머신의 플랫폼에 독립적으로 운용할 수 있는 장점. 프로그램이 이식성을 가지고 다른 시스템에 이식 가능. 개발시 소프트웨어 환경에 구애받지 않고 다양하게 개발 가능

시물레이션과 같은 일을 할때 피지컬에 구애받지 않고 운용 가능

#### 단점

VM상에서 돌아가는 모든 코드는 인터프리터(엔진)에서 인터프린팅 하는 과정이 추가적으로 필요하다는 점.

## 아키텍쳐

### Plug-In 아키텍쳐

바뀌어지는 시스템 요구사항에 적응력이 매우 빠른 아키텍쳐. 플러그인 하는 것은 extension해주는 것이다. 예를들어 TV셋에 언어가 있는데 언어팩을 다른것을 플러그인하면 다른 언어로 보이는 효과. 기본적으로 돌아가는 구조가 있고 extension을 넣어주면 넣은 값대로 쓸 수 있는 것. 

product-based한 application. 제품을 만들어서 제조업과 같은 기계에서 Plug-in 의 feature를 가지고 이미 출고한 제품을 관리 할 수 있는 것이다. plugin이 있고 core가 있다. 

코어가 TV set. 언어팩이 plug-in 기능적인 확장성이 제공괴는 것. 

#### 구조

플러그인 모듈들이 있는데 이들은 독립적. 서로 관련 없는 것들. 그리고 코어가 있다. 플러그인 아키텍쳐 스타일은 외부 확장성. 유연성을 가진다. 

##### Core

기본적인 기능성. 시스템이 작동 되도록 하는 역할에 충실. 예를들어 시스템 오퍼레이션 등

##### plugin

확장팩처럼 들어가는 것. 다른 모듈과의 디펜던스가 없고 독립적인 것. processing, features, custom code. 코어 시스템보다 더 확장성 있는 기능을 제공

#### Consideration

어떻게 플러그인을 코어에 연결 할 것이냐. 플러그인 레지스트리. 플러그인에 대한 정보를 알 수 있다. 어떻게 커뮤니케이션 하는 것인지 등이 나타나 있다. 

#### 예시

##### Eclipse IDE

기본적으로 이클립스 IDE지만 확장해서 이용 가능 하다. 이클립스 예에서는 확장에 대한 확장도 볼 수 있다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-15 오후 10.10.39.png" alt="스크린샷 2020-04-15 오후 10.10.39" style="zoom:67%;" />

##### Internet browsers

렌더링이나 뷰를 원하는대로 한다던지 알고리즘을 다른것을 사용한다던지 할 수 있음.

##### Claims processing(일반적 예제)

보험회사라고 예시를 들어보자. 어느 지역에 대해서 시작을 한다고 하자. 이것이 잘 되서 다른 지역에 론칭하려고 한다. 보험회사에 대한 클레임 시스템은 그대로 있는데 다른 지역에 법 체계 등에 맞춰야 하는 상황이 왔다. 그것을 플러그인으로 넣는다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-15 오후 10.08.47.png" alt="스크린샷 2020-04-15 오후 10.08.47" style="zoom:67%;" />

##### Chrominum Architecture

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-15 오후 10.14.34.png" alt="스크린샷 2020-04-15 오후 10.14.34" style="zoom:100%;" />

플러그인과 렌더러가 있다. 다른 렌더러나 플러그인으로 IPC통해 연결. 

##### Firefox Architecture

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-15 오후 10.20.02.png" alt="스크린샷 2020-04-15 오후 10.20.02" style="zoom:67%;" />

##### Internet Explore Architecture

#### 장점

우리가 필요에 따라서 요구사항이 제품이 완료된 후에도 요청할 때 플러그인을 통해 추가 가능. portability, Flexibility

Separation of Policy and mechanism

## 아키텍쳐

### Cloud Computing

자원이 어딘가 외부에 있는데 그것을 대여해서 사용하는 자원을 대여해서 쓰는 유틸리티 모델을 클라우드 컴퓨팅이라고 한다. 컴퓨팅 서비스도 유틸리티 서비스로 보자는 것임. 그것을 사용한 만큼 지불하는 비지니스 패러다임. VM의 활용을 최대화.

### Microkernel

플러그인과 마이크로 커널을 한 세트로 보기도 하는 경향이 있다. (또 어디서는 구분 하긴 함.) 플러그인과 마이크로 커널은 내부 설계가 매우 유사. 프로덕트 베이스 - 플러그인, OS 베이스 - 마이크로 커널.

#### 예시

초기 하이드라에서 이 마이크로 커널을 제시. 드라이브와 OS를 분리시키는 마이크로 커널을 제시. 마이크로 커널은 하드웨어 플랫폼에 이식할 수 있는 형태를 가짐. 필요에 따라 개발환경이 변경되도 제공 가능. 다른 OS에서 돌아가는 시스템에도 쉽게 제공

#### Context

여러 어플리케이션을 개발하는데 있어 하나의 커널/시스템에서 작업을 할 수 있도록 하는 여려 유연성을 제공하자는 취지에서 OS레벨에서 커널은 작게 만드는 아키텍쳐 스타일을 제공한다.

#### 문제

GUI와 같은 형태, 필요에 따라 계속해서 이어나감. 플랫폼과 어플리케이션이 분리..? 플랫폼이 필요에 따라 확장이나 외부 연결 가능하게 하기 위해 마이크로 커널이 나왔다. 

#### 구조

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오전 10.52.04.png" alt="스크린샷 2020-04-17 오전 10.52.04" style="zoom:50%;" />

클라이언트 입장에서 어댑터를 통해 외부 서버위에 어플을 돌릴수도. 마이크로 커널을 통해 내부서버에 접근하는등 가능함.

기본적인 서비스를 인캡슐레이션 하면서 커널은 작게 하면서 어플리케이션을 서비스로 구분하게 됌. 코어한 기능을 어사인 해준다. 코어한 드라이버 같은것은 내부 서버에서 separation해준다. 외부 서버는 안에있는 마이크로 커널 위에서 올라가서 구현해서 운영되도록. 클라이언트는 외부서버를 접근할때 어댑터를 통해 접근

##### CRC

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오전 10.54.37.png" alt="스크린샷 2020-04-17 오전 10.54.37" style="zoom:50%;" />

마이크로 커널은 서비스를 제공하는 역할. 시스템에 어떠한 것이냐에 따라 디펜던시를 가지고 있다. 외부에서는 안단에 내용을 모름. Atomic service. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오후 1.26.28.png" alt="스크린샷 2020-04-17 오후 1.26.28" style="zoom:67%;" />

내부 서버. 내부적이 서비스를 드라이버 레벨에서 구현 시스템에 아주 세부적인 것을 캡슐화 하여 가지고 있고 기능성을 더 확장할수 있는 기능 가지고 있고, 하드웨어와 소프트웨어를 디펜던시를 가지고 있는데 그것을 인캡슐 한다. 필요에 따라서 오퍼레이션이 되도록 한다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오후 1.28.07.png" alt="스크린샷 2020-04-17 오후 1.28.07" style="zoom:67%;" />

외부서버. 인터페이스를 가지고 접근할 수 있도록 제공. 어플리케이션 도메인마다 그 위에서 돌아갈 수 있는 구조. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오후 1.29.02.png" alt="스크린샷 2020-04-17 오후 1.29.02" style="zoom:67%;" />

클라이언트는 어플리케이션을 접근. 어댑터는 클라이언트에게 시스템을 접근 할 수 있도록 한다. 내부를 숨겨주는 역할. 클라리언트의 리퀘스트에 적절하게 매핑하는 역할. 클라이언트와 외부서버간 중재의 역할. 

#### Dynamics

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오후 1.30.28.png" alt="스크린샷 2020-04-17 오후 1.30.28" style="zoom:67%;" />

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오후 1.31.58.png" alt="스크린샷 2020-04-17 오후 1.31.58" style="zoom:80%;" />

외부서버에서 요청이 들어오면 내부서버에 요청 주고 처리해서 받고 그것을 주고.. 

#### Microkernel vs monolithic kernel.

모놀리틱은 모든 OS가 모든일들을 하고 있는것. 해야할 일이 많다. 무겁게 된다. 마이크로는 커널을 작게 만들어서 필요한 드라이버, 필요한 라이브러리를 끼워서 이용. 필요한 것으로 작게 오퍼레이션이 주어지고 필요한 것만 이용하게 된다.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-17 오후 1.35.19.png" alt="스크린샷 2020-04-17 오후 1.35.19" style="zoom:67%;" />

#### 장점

이식성이 좋고, 유연하고, policy and mechanism을 분리가능. 확장성 신뢰성 퍼포먼스등 좋아지고 디자인에 대한 유연한 관리 가능.

#### Summary - 계층 아키텍쳐

소프트웨어 시스템을 계층적으로 구분해서 이용.구조를 잡아갈 때 아주 좋은 형태. 분해를 할때 어떤 형태로 레이어를 자를 것인지를 결정하게 되고 바운더리에 대한고민. 분해한 서브 시스템을 어떻게 뽑을 것인지. 어떻게 서비스를 구성할 것인지. 어떻게 연결할 것인지. 예외 처리에 대한 핸들링 등 중요.

## 아키텍쳐

### Distributed Architecture

분산 시스템이라고도 함. 

#### 정의

컴퓨터들의 집합이라고 생각하면 된다. 각기 독립적으로 자신의 플랫폼. 하드웨어와 OS를 가진 컴퓨터들이 집합체로 모여있는 시스템을 분산 시스템이라고 한다. 분산시스템에 모여있는 특징으로 인하여 보면 네트워크로 반드시 연결되어 있어야 상호간 호환된다. 

분산 시스템은 네트워크로 연결되어 커뮤니케이션, 서로 교통 또는 통신을 할 수 있는 컴퓨팅 리소스들의 집합. 거기에 따라서 컴퓨테이션널 앤드 스토리지 디바이스도 있긴 하다. 

그래서 분산 시스템은 컴퓨팅 뿐만아니라 스토리지도 포함한다고 볼 수 있다. 독립적인 다른 시스템을 연결하기 위해 여러가지 다른 메세지를 보낸다던가 RPC(remote procedure calls), RMI(Remote method invocation)을 이용하여 다른 분산 객체를 부를 수도 있다. 

외부에서 봤을때는 마치 하나의 시스템 이미지로 접근 하는 것처럼 보인다. 

#### 구조

분산시스템을 이루기 위해 통상 네트워크로 이루어 진다. 네트워크 토폴로지 위에서 커뮤니케이션의 상태 메소드 접근방식 어떤 레이어에서 접근할지 등 통상적으로 정의하는 커뮤니케이션 모드가 있다. 

다른 여러 아키텍쳐 스타일로 표현 할 수 있다. 클라이언트 서버 아키텍쳐, 멀티 티어 아키텍쳐라던가 등등.. 

그리고 COBBA와 같은 broker아키텍쳐를 쓰는것이 무엇인지. 그리고 SOA가 무엇인지. 

분산 아키텍쳐는 주요한 특징이 있는데 ㅡ, transparency, Reliability and availability

분산 아키텍쳐를 지원하는 프레임워크가 있다. 

#### 관점

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-22 오전 12.08.21.png" alt="스크린샷 2020-04-22 오전 12.08.21" style="zoom:50%;" />

## 아키텍쳐

### 클라이언트-서버 아키텍쳐

많이 사용되는 구조, 분산시스템 구조에서 가장 일반적으로 이용 가능한 구조. 두개의 프로세스가 각자 다른 노드에 적재되어 있어서 서로가 커뮤니케이션을 통해 각자 담당한다. 하나는 클라이언트 하나는 서버라고 명명. 

프로세서는 컴퓨팅 하는 노드. 프로세스는 실행되는 프로그램이다. 다른 두 컴퓨팅 노드에 클라이언트라고 명칭 되어진 프로그램을 돌리면 클라이언트 노드, 서버라는 이름의 프로그램을 다른 노드에 돌리면 그 노드는 서버 노드. 그러면 클라이언트와 서버의 역할

클라이언트는 서버에게 리퀘스트를 보내는 프로그램. 서버는 클라이언트로부터 리퀘스트를 받고 그러고 나서 그것을 처리하고 그리고 나서 클라이언트에게 결과를 돌려줌. 서버가 핵심인 형태. 이 서버는 통상 항상 클라이언트가 리퀘스트를 하기를 기다리는 형태. 서비스 노드가 항상 돌아가고 있다고 볼 수 있다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-22 오전 12.19.54.png" alt="스크린샷 2020-04-22 오전 12.19.54" style="zoom:50%;" />

리퀘스트에 관련된 프로세스 돌아가는 컴퓨팅은 서버측에서 서비스 하면서 프로세싱한다. 

#### 티어에 대해 

티어는 배치의 문제이다. 1:프론트티어,2: 웹서버 티어,3: 웹 어플리케이션 티어... 앞에 있던 그런 Master-Slave 같이 생긴 것을 티어로 놓는 것이다. 

Two tier

클라이언트 단 / 서버 단. 클라이언트 단에서 서버단으로 요청을 보내는 것이다. 두개의 티어를 가지고 있다고 통상적으로 볼 수 있다. 

#### 장점

클라이언트와 서버의 각자 책임이 존재. 그것을 해야하는 프로그램이 다르게 프로세스화 하여 다른 노드에 적재한다. 

***Separation of responsibilities.***

서버는 필요에 따라 재사용 가능하다. 

#### 단점

만일 분산 시스템에서 다른 종류의 시스템을 (다른 하드웨어 다른 플랫폼 + 프레임워크) 이종의 인프라 스트럭쳐를 가지고 있을때 이것에 대한 리퀘스트를 어떻게 주고받을 것인지 문제. 

보안상의 문제도 있음.

서버가 항상 대기상태여야 하는점도 문제. 서로 신뢰성도 갖게 해야한다. 

테스팅이 가능한지, 여러 클라이언트로 스케일 아웃 할 수 있는지 . 여러 클라이언트가 접근 가능한지 등 다양한 요소를 고려 해야 한다.

## 아키텍쳐

### 멀티 티어 아키텍쳐

#### 원티어 아키텍쳐

원티어라는 것은 한 컴퓨터 안에 모든 코드를 다 가지고 있는 형태. 외부에서 클라이언트가 연결해서 사용하더라도 사용자는 dumb-terminal을 연결해서 쓰는 형태라고 할 수 있다. 이런 형태는 monolithic하다. 전체 모듈이 하나의 메인 프레임에 들어있다. 

##### 모놀리틱 정보 시스템에 대해 

프레젠테이션 하는 부분, 어플리케이션에 대한 프로세싱하는 부분, 디비와 같은 리소스를 접근하고 처리하는단계. 이것을 레이어로 잘랐다. 

![스크린샷 2020-04-27 오전 11.49.19](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.49.19.png?lastModify=1592460542)

인포메이션 시스템이라는 것은 통상 이렇게 세가지 기본 구조를 가진다. 모든 코드를 한 노드에 적재 하는 것을 원 티어 아키텍쳐라고 한다. 외부에서 접근하는 것은 터미널로 접근하게 한다. 

#### 투 티어 아키텍쳐

두개의 노드. 통상 두개의 노드가 있는데, 프레젠테이션 노드를 따로 놓고, 어플리케이션 + 리소스 레이어를 따로 놓느다. 

![스크린샷 2020-04-27 오후 12.12.43](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.12.43.png?lastModify=1592460542)

어플리케이션 + 리소스 레이어는 서버에 적재한다. 

##### 투 티어 클라이언트 서버 아키텍쳐

![스크린샷 2020-04-27 오후 12.14.25](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.14.25.png?lastModify=1592460542)

Information System. 에서 어디를 자를 것인가 하는 것이다. (a) ~ (e). (a)를 보면 유저 인터페이스 부분이 적당히 분리 되어 있는데, 이렇게 프레젠테이션 레이어를 완전하게 분리할 필요는 없다. 필요에 따라 분리 가능. 



클라이언트 서버 아키텍쳐 구조가 많다. 사용자에 관한 처리에 대한것이 Client에. 리소스 등을 저장학고 적재 하는 것이 서버측에. 서버에 통상 관리자가 있을 수 있다. 다른 종류의 서버들 반드시 연동되어야 하는 레거시 시스템이 같이 물려서 이용. 

클라이언트는 두가지로 나뉨.

- Thin

  가벼운 일들이 있는 클라이언트. 하는일이 조금 적고 전력이 제한되고 그러한 기능을 탑재하는 클라이언트.

- Fat

  상탄 (a) ~ (e) 그림중 우측으로 갈 수록 팻한 클라이언트. 처리가 많음. 

#### 쓰리티어 아키텍쳐

![스크린샷 2020-04-27 오후 12.34.43](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.34.43.png?lastModify=1592460542)

클라이언트 쪽에 있는 티어와 서버 티어 중간에 어떤 어플리케이션 관련 일을 담당하는 티어가 제공되는 형태. 다른 컴퓨터에 설치하고 운용하려고 할때 어떻게 배치하고 이용할 것이냐 하는게 배치라고 한다. 레이어 != 티어. 레이어별로 배치가 되긴 했지만 같지 않음. ***티어는 배치 문제이고, 레이어는 계층적, 구조적으로 만드는 방법이다.\* 티어는 어떤 노드에 어떻게 배치할 것이냐 하는 문제임.** 

**통상 이 그림의 예는 레이어별로 티어를 나누었음. 비지니스 로직을 미들 티어에 두었다. 프로세싱만 하는 노드를 적재 시켰다.** 

**가장 일반적인 인터넷 검색에 대한 예**

**![스크린샷 2020-04-27 오후 12.40.26](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.40.26.png?lastModify=1592460542)**

**인터넷에 들어가서 제품을 선택한다고 한다면, 서버 단에 이 쿼리를 받아서 작업하는 것이 있고, 데이터베이스만 처리하는 데이터 레벨단이 따로. 유저의 티어 따로. 유저/프로세싱/데이터 세가지 티어로 나뉜것.** 

##### **2티어 vs 3티어**

**3티어는 프로세싱을 하는 중간단계의 미들 티어가 존재한다. 이런 미들 티어를 이용 하면 좀더 scalable, robust, flexible한 서버단을 마련 할 수 있다. 프로세싱이 많아지면 중간 프로세싱에 대한 노드를 더 넣을수도 있고, 데이터가 많아지면 데이터 단에 대한 노드를 늘릴 수 있다. 각 스케일에 대한 크기를 조정 가능하다. 각 노드가 죽지않는 robust한 시스템이 된다. 유연성 있게 운용이 가능하게 된 것이다.**

**다른 종류의 일들을 각각 scaleout할수 있는 멀티플 소스로부터 데이터를 인티그레이트 할수 있는 좋은 구조를 가지고 있다.**

**예를들어 TP Monitor 분산 오브젝트. 웹 등**

**![스크린샷 2020-04-27 오후 12.46.38](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.46.38.png?lastModify=1592460542)**

**서버단은 필요에 따라 스케일 아웃 가능.** 

**![스크린샷 2020-04-27 오후 12.47.24](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.47.24.png?lastModify=1592460542)**

**수직적으로 일을 해나가는 형태**

#### **멀티티어** 

**N티어 라고도 함. 상황에 따라 시스템의 요구사항에 따라 티어를 여러 단계로 나누는 것. 중간에 미들티어가 여러 단계가 있음. 리소스도 여러 단계를 넣을 수 있다. 프론트엔드 티어는 유저에 관련된 사용자 친근의 티어. 미들티어는 비지니스 로직이나 실행의 로직, 백엔드 티어는 사용자에게서 거리가 먼 처리. 데이터의 처리 등. 엔터프라이즈 어플리케이션 등에서 널리 사용.** 

**![스크린샷 2020-04-27 오후 12.50.41](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.50.41.png?lastModify=1592460542)**

**멀티 티어로 나간다는 것은 미들 티어를 여러개로 나눌수도 있고 백엔드 티어를 더 확장시켜서 나갈 수 있는 구조도 있다.**

#### **예시**

##### **5티어**

**![스크린샷 2020-04-27 오후 12.51.42](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.51.42.png?lastModify=1592460542)**

**클라이언트는 다양한 유저들이 브라우저를 통해 접근. 브라우저에 돌아가는 일들을 어느정도 정립한다. 브라우저에 돌아가는 프로그램들을 클라이언트에서 제공. 클라이언트 하나의 티어. 그다음 웹서버 웹사이트에서 제공. 인터넷으로 접근. 퍼블릭하게 웹서버에 접근 가능. 많은 경우에 웹서버는 공격에 취약함. 하나의 클라이언트가 웹서버에 로그인 하겠다고 하면 이 요청에 따라 세션을 유지해주는데, 이것은 프로토콜을 맞춰주고 메모리를 유지하고 관리가 필요함. 굉장히 많은 클라이언트가 리퀘스트를 보낸다면 성능이 떨어지고 심지어 죽기도 한다.** 

**회사에 대한 주요한 어플리케이션 서비스는 따로 어플리케이션 서버를 두어 안전하게 한다. 오퍼레이션/기능/리퀘스트 위주의 어플리케이션 서버. 이것과 연결되는 DB라던가 레거시 ERP시스템 등 스토리지관련 리소스 티어.**

**이렇게 클라이언트 - 웹서버 - 웹 어플리케이션 서비스 - 리소스 4티어**

##### **장점**

**재사용성, scalability 보장. 필요에 따라 스케일을 확장 가능함. 어플리케이션의 오퍼레이션이 변경 될때마다 미들티어 단에서 언제든지 반영 가능. portable하다. 유연성을 가지고 있고 이식성도 있다. 필요에따라 서비스 론칭 가능. 스탠다드한 설계 가능.** 

**트래픽을 좀더 효율적으로 관리 가능. 디도스 공격 등에 대해 어플리케이션 서버를 안전하게 보호. 트래픽 적절한 운용 가능. 문제는 테스팅이 쉽지 않음. 노드들이 다 나누어져 있기 때문. 여러개의 서버를 관리한다는 것은 어려움이 따를 수도 있음.** 

## 아키텍쳐

### 프록시 아키텍쳐

진짜가 아닌 가상의 연결점이라고 보면 된다. 외부의 오브젝트가 있다. 이것은 Distributed 오브젝트라고 하고 이것은 노드에 있다. 그리고 클라이언트가 있다. 디스트리뷰트는 굉장히 헤비한데, (디비가 달리거나 큰 시스템이 연결됨.) 이것을 클라이언트가 돌릴 수 없는데, 이때 클라이언트 노드 안에 프록시를 넣는 것이다. 외부에 있는 리모트한 노드의 분산 객체에 해당되는 것. 이 클라이언트는 내 노드에 있는 오브젝트를 호출하듯이 이용하면 되고, 프록시는 외부에 있는 노드의 오브젝트를 이용하는 것이다. 

다른 오브젝에 대한 surrogate를 제공. 진짜는 아니지만 모든것을 제공하는 껍데기. 모든 메소드 콜은 인다이렉트하게 간다. 디스트리뷰트를 직접 호출이 아니고 프록시를 간접적으로 불러 호출. 프록시는 실제 있는 오브젝트에 관련된 인터페이스를 공유해서 마치 이 클라이언트 프로세스가 디스트리뷰트 오브젝트를 직접 연결하는 듯한 환상을 제공한다. 

프록시를 하게 되는 경우에서 디스트리뷰트를 실행하는 것은 서버단에서 실행이 되는 것으로 볼 수 있다.

##### Context

Transparent manegement를 할수있다(투명성) 현실화된 오브젝트가 있는데, 내부적으로 인식하지 않아도 그 현실적인 오브젝트를 실행 될 것이라는 믿음을 가지고 투명성을 제공한다. 

다른 오브젝트에 대한 투명한 관리를 가짐. 

리얼한 오브젝트를 담당해서 인보케이션 해 줄수 있다. 메소드가 리얼한 오브젝트를 인보케이션 하고 그것이 완료되면 그 시점에 리턴값을 주게 된다.  프록시는 클라이언트에 없는데 있는것 같은 환상을 가지게 되어 로컬에서 사용하는 것처럼 한다. (Remote proxy)

Access control. 외부에 리모트 하려 하는데, 복잡한 절차가 있다고 하자. 관리자 입장에서 직접 접근 하고 싶은데 이것에 대한 제공자를 제공할 수 있다. remote한 오브젝트를 접근하는 접근자를 프록시로 제공. 우리가 원하는 접근을 해주도록 함

Virtual proxy. 로컬쪽에서 실제로 리모트한 서버에 접근을 하지 않음. 내부에 대한 테스팅을 수행할 때, 아직 구현되지 않은 기능에 대해 테스팅을 수행할때 외부의 것이 개발되어 있지 않으면 테스팅이 불가능한데, 프록시를 두어 마치 작업을 수행한 것처럼 보이게 하여 테스팅을 수행 할 수 있도록 한다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-27 오후 2.31.20.png" alt="스크린샷 2020-04-27 오후 2.31.20" style="zoom:50%;" />

##### Dynamics

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-27 오후 2.32.29.png" alt="스크린샷 2020-04-27 오후 2.32.29" style="zoom:67%;" />

Client-Proxy / Service는 다른 노드임. 마셜링 프로세스가 필요함. 외부 오브젝트와 커뮤니케이션 할때 시리얼라이제이션 하는 형태를 마셜링,언마셜링이라고 함.

##### 장점

오리지널한 디스트리뷰트 오브젝트를 접근할 수 잇는 장점. 내부에 가지지 않고 프록시만 가지고 외부의 컨트롤 할 수 있다는 장점. 클라이언트의 리소스 세이브. 퍼포먼스도 분리되어 이득.

하우스키핑(유지보수) 헤비한 서버한쪽을 유지보수 하고 클라이언트는 기능적 유지보수. 

포텐셜 오버킬. 프록시가 어떤 경우에는 여러다리 걸치는 것일 수도있다. 여러 티어일수도 있다는 의미인데, 계속적으로 인다이렉트 레벨이 많아질 수 있는데 네트워크를 통해서 가야하는 것이 많아질 수 있어서 언제 폭탄이 터질지 모르는 위험부담이 존재. 만일 소식이 안온다면 어느 프록시나 네트워크가 잘못된건지 파악하기가 어려움. 추적관리가 어렵고 테스팅도 어렵다. 여러 단계에 걸친다면 좋지 않음. 

## 아키텍쳐

### P2P

Peer to peer 의 준말. 피어가 다른 피어에게 구조를 동질하게 가지는 형태. 서버와 클라이언트 시스템을 본적이 있을 것이다. 서버는 리퀘스트를 기다리고 요청이 오면 그것에 대한 서비스를 담당하는 프로세스 존재. 이후 클라이언트에게 응답을 준다. 그런데 피투피는 모든 노드의 역할들이 클라이언트도 되고 서버도 되는 구조를 말한다. 서로가 클라이언트이자 서버인 것이다. 모든 노드가 서버의 역할을 하고 필요에 따라 다른 피어의 리퀘스트를 보낼 수 있는 역할을 가짐. 

분산아키텍쳐. 태스크와 워크로드가 분리되어있어서 모든 피어가 담당하는 일을 가지고 있다. 각 피어는 동격의 권리를 가진다. 피어들끼리 묶어서 하나의 어플리케이션, 또는 전체적인 어떤 일을 담당. 같은 레벨의 권리를 가지고 그 어플에 참여한다. 이것을 시메트릭한 롤이라고 한다.(symmetric roles) 

이런 피투피를 왜 하느냐. 피어들이 합쳐져서 큰 일을 해내도록 함. 리소스 문제. 피투피에 연결된 각 피어들은 각자 리소스를 가지고 있고 다른 피어가 그 리소스를 쉐어할 목적을 가지고 피투피 아키텍쳐 구조가 형성됨. 이 구조는 processing power일 수도 있고, 씨피유 파워, 아니면 콘텐트일수도 있다. (음원이라던가) 스토리지 일수도 있다. (디스크 스토리지) 네트워크 대역폭 등 여러 이유가 있다. 피투피를 나누는 이유는 리소스를 공유할 수 있는 목적. 다른 피어들이 리소스를 이용하게 하도록. 

피투피라고 하게돠면 어떤것을 공유할 것인지가 핵심. 콘텐트, 파워, 리소스 등.

요청하는 입장이나 받는 입장이나 모든 노드들이 같은 형태의 권한을 가지고 연결을 이어 나간다. 

#### 아키텍쳐 스타일

##### 장점

중앙집권적 컨트롤러가 없고 모든 노드가 같은 권한으로 리퀘스트와 리스폰스. 센트럴 서버가 없다. 중앙집권적 컨트롤 서버가 없음. 피어들이 자유자재로 다른 피어들과 연결. 실패가 일어날때 하나가 죽으면 다른것도 다 죽는 현상 없다. 피어들은 거의 같은구조이기 때문에 필요에따라 계속 붙여나갈 수 있음. 확장성이 있음. 

- No central point of failure
- Scalability

다른 종류의 플랫폼을 가지더라도 어플리케이션이 충분히 돌아 가도록 유연하게 처리. 

##### 단점

전체 통제를 하는것이 다 분산되어 있어서, 글로벌한 컨시스턴트를 가질 수 없음. 전체 구조를 하나의 스냅샷으로 처리 할 수 없다는 것임. 통제를 한다는 것이 어렵게 됨. 그래서 distributed coherency protocols 필요함. 

모든노드들이 같은 시점에서 만들어지지 않음. 각자 다른 특징이 있음. 시작하는 시점이라던가 리소스가 다름. 각 노드들에 따라 전체 시스템에 영향 끼칠수도. 

보안이 약함. 

#### 리소스

##### CPU

seti@home, GIMPS

##### Bandwidth

PPLive,PPStream 라이브나 스트리밍 서비스.

##### Storage space

OceanStore, Murex

##### Data

Napster, Torrent

##### People

Buddy Finder

##### Camera, Microphone, Sensor, Service, etc...

각 피어들이 디바이스가 가진 장점을 이용해 피투피 서비스 제공.

#### Classification

피어들은 협력하는 구조. 계속 붙여나갈수 있는 형태. Overlay network. 마치 인트라로 연결된 듯한 효과. 

##### Pure P2P

Central 한 포인트 없음. 각자 피어가 전체 구조를 연결해서 계속적으로 이 구조를 키워나갈 수 있는 형태. 전체 커뮤니케이션은 센트럴 서버 도움없이 일어남. 작은 스케일에 유용. 

서로 인지하면서 포트를 열어 커뮤니케이션 하는 형태

##### Hybrid P2P

여러개를 붙임. 부분적으로 센트럴 서버를 가지게 함. 

예를들어 암호 어플리케이션이라고 한다면, 검증된 사이트에서 데이터를 다운로드 받고 싶어 한다. 센트럴 서버에서 다운로드 받고 프로세스를 거침. 센트럴한 서버가 정보를 가진다. 어떠한 데이터를 의논하고자 한다면 센트럴 서버에 커넥션 하면 다른 피어들과 연결. 부분적으로 로그인 이나 멤버쉽과 같은 형태의 것만 센트럴 서버가 제공하고 이후의 것들은 피어에게 맡긴다.

부분적으로 센트럴 서버가 운용된다. 

##### Unstructured P2P

구조를 갖지 않음. 필요에 따라 붙여나감. 센트럴 서버 없음. 연결할때 필요에 따라 계속해서 붙여나감. Overlay network

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-04 오후 5.14.44.png" alt="스크린샷 2020-05-04 오후 5.14.44" style="zoom:67%;" />

##### Structured P2P

구조를 가지고 있음. 토폴로지를 어느정도 구성해서 어드레스 체계를 가지게 함. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-04 오후 5.14.53.png" alt="스크린샷 2020-05-04 오후 5.14.53" style="zoom:67%;" />

distributed hash table(DHT) 등을 가짐. 로지컬 어드레스를 가짐. 위치를 찾아 갈 수 있다. 

- Distribute Hash Tables

  로케이션, 서버 특징, 콘텐트, 리소스 스타일 등 가지고 있는 상태에서 해쉬를 돌려줌. 그러면 키가 나온다. 이러한 키로 유니크한 아이피 어드레스를 가지고 대칭 시킴. 

##### BitTorrent

피투피를 이용한 파일 쉐어링 프로토콜. 내 파일과 다른 파일의 노드가 공유 되도록 함. 큰 파일에 적용. 비디오나 오디오 등의 파일. 

##### Blockchain

가상화폐뿐 아니라. 블록체인에도 이용됨.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-04 오후 5.19.28.png" alt="스크린샷 2020-05-04 오후 5.19.28" style="zoom:67%;" />

## 아키텍쳐

### 브로커 아키텍쳐

분산적으로 시스템들이 있을때 중간자 (미들웨어 아키텍쳐) 를가지고, 서버쪽 서비스가 레지스터됨. 클라이언트는 서버쪽 정보를 모른다. 사용자는 중간자에게 정보를 넘기면 중간자가 적절한 서버에게 전송한 뒤 정보를 받는다. 

분산상의 시스템 아키텍쳐를 제공. 리모트한 서비스를 제공하여 분산 오브젝트를 다른 위치에 있는 클라이언트가 사용할 수 있도록 함. 커플링을 낮추는 효과를 얻을 수 있음.

브로커는 코디네이터 중간 역할. 상호 연관 되도록 도와줌.클라이언트가 리퀘스트 하는 것을 전달. 결과가 다시 클라이언트에게 전달함. 에러나 예외도 전달함. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-11 오후 1.27.56.png" alt="스크린샷 2020-05-11 오후 1.27.56" style="zoom:80%;" />

이종 서버 시스템. heterogeneous한 시스템. 각 서버는 독립적 운행함. 각 서버를 브로커에 등록한다. 클라이언트가 브로커에서 이러한 정보가 필요하다고 제공하면 브로커가 서버에게 넘겨주고 처리하여 반환함. 

인보케이션 위주로 처리될 요지가 존재함. (호출의 형태로 처리). Document, message-oriented하게 처리될 경우가 높음. XML형태로 처리될 가능성이 높다. 

서버와 클라이언트의 퍼포먼스를 증가 시키고 여러가지 퀄리티 어트리뷰트를 달성 하도록 한다. 브로커는 프록시 베이스 시스템으로 이루어져 있다. 

서버는 자기의 서비스를 등록 할 필요각 있고, 인터페이스를 제공해야 한다. 

예시 CORBA(Common Objectt Request Broker Architecture) 

브로커는 클라리언트 서버 구조를 디커플 할 수 있는 아키텍쳐.

- 서버

  브로커에 등록. 인터페이스를 브로커에 전달함

- 클라이언트

  서버를 콜 하듯이 브로커에게 전달 하면 브로커가 처리해서 줌.

- 브로커

  서버의 서비스를 위치정보를 등록하거나 알고있음. 클라이언트의 요청을 서버에게 전달. 결과를 전달한다.

#### Solution

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-11 오후 1.36.17.png" alt="스크린샷 2020-05-11 오후 1.36.17" style="zoom:80%;" />

프록시를 거쳐서 통신. 브릿지는 다른 브로커들과 통신할때 이용하는 것. 

브로커는 코디네이터 역할. 요청을 처리함. 서버쪽 등록정보와 역할, 위치를 가지고 있음. 인터페이스 또한 가지고 클라이언트에게 제공한다. 

클라이언트 사이드 프록시(Stub) 클라이언트와 브로커 사이의 중간자 역할. 브로커와 클라이언트 쪽이 투명성을 가지게 된다. 외부 오브젝트가 로컬 오브젝트 처럼 다룰수 있도록 함. 내부의 것이 외부로 갈때 숨기는 역할.보내는 파라미터에 대해 마셜링을 수행한다. 

서버 프록시(Skeleton). 인터페이스의 형태만 가지고 이것을 제공함. 시스템적인 내용을 인캡슐레이션. 언 마셜링 하는 효과. 적절한 서비스를 인보케이션. 

브릿지. 다양한 브로커와의 연결. 확장구조를 가지도록 도와줌. 

#### Dynamics

일반적인 다이나믹이 있고, 아래와 같은 것도 있다.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-13 오전 10.47.15.png" alt="스크린샷 2020-05-13 오전 10.47.15" style="zoom:80%;" />

스트리밍 같은 서비스의 경우 브로커가 계속 forward 할 필요가 없으므로 브로커가 위치 정보를 클라이언트 프록시에게 주고 직접 연결 하도록 하는 경우가 있다. 

#### Example - CORBA

분산 객체에 대한 브로커. 오픈 스탠다드. 분산 객체를 외부에서 사용할 수 있는 표준화 체계. 플랫폼,랭귀지 인디펜던트 함. 외부에 있는 오브젝트 제공 가능. IDL(interface definition language)통해 제공. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-13 오전 10.51.46.png" alt="스크린샷 2020-05-13 오전 10.51.46" style="zoom:80%;" />

필요에 따라 facilities이용 가능하다. 

#### 장점

로케이션 트랜스패런시. 어디든 투명성있게 제공한다는 것. 히든되게 제공한다는 것임. 서버가 언제든 바뀔 수 있고 확장 가능한 형태. 

클라이언트는 브로커만 통해서 서버연결 가능. 서버 확장 가능. 브릿지를 통해 연결 가능하고 reusability. 실행시간 동안 서버가 변경되는 것을 반영 가능

#### 단점

프록시가 많은것이 단점임. 

## 아키텍쳐

### 메세지 브로커

클라이언트 메세지 전달. 브로커가 메세지를 받아 서버에 전달한다. 메세지로 운영되는 형태임. XML Document같은 것을 보내게 되면 브로커는 MOM(message-Oriented Middleware)을 통해 처리시킴.

메세지 라우트 메세지 변환 인보케이션이나 보안 확인 예외 처리 등 처리함.

##### MOM(message-Oriented Middleware)

메세지로 운용되는 미들웨어. 클라-서버 에서 서버 프로세서가 항상 대기해야 한다는 단점이 있음. 또한 서버에 대한 모든 정보를 가지고 있어야 하고 프로토콜을 맞춰야 한다는 점이 있다. 서버 또한 많은 요청에 대해 처리 문제가 존재한다. 

클라-서버 사이에 리퀘스트를 보낼때 버퍼를 둔다. 이 버퍼에 리퀘스트를 보내고, 서버는 자신의 일 처리에 따라 이 버퍼에서 리퀘스트를 가져다가 처리한다. 리스폰스때도 버퍼에 값을 두어 서버가 버퍼에 보내고 클라가 버퍼에서 값을 가져온다.

디커플링 효과를 가져올수 있다. 

리퀘스트 보낼때 좀 크면 메세지 단위로 처리하게 된다. 이러한 구조를 MOM이라고 칭함. 

##### Message Broker

메세지를 보내는데 메세지 브로커는 이 메세지를 라우팅 한다. 메세지의 content에 따라서 필요한 시스템에게 전달함. 브로커는 메세지를 다른 형태의 포맷으로 변경 해 줄수도 있음. 필요에 맞추어 제공한다. 데이터를 보낼때, modify, inserting, merging, remove 등 여러 작업들이 추가 될 수 있음. 

필요에 따라 라우터를 통해 전달. 만일 서버로 바로 전달해도 괜찮을 경우 그렇게 처리한다. 메세지 브로커는 메세지 단위로 처리하고 다른 메세지 브로커로 라우팅 할 수도있으며, 변환하여 사용할 수도 있는 형태이다. 

#### Application

메세지를 다른 시스템에 분배. Publishing, subscribing 되도록. 토픽을 등록하면 브로커로부터 해당 토픽에 대해 받아 볼 수 있다. 

##### Commercial 

MQSeries, JMS 등

#### 장단점

계속적으로 reuse가 좋아짐. 컴포넌트 재사용 가능. 커플링이 낮아지고 쉬운 extension. Flexibility

여러 브로커를 통해 거쳐가서 오버헤드, 인다이렉션, 복잡성 증가

## 아키텍쳐

### 디스패쳐 아키텍쳐 - 로드밸런서

디스패쳐는 만약에 클라이언트의 관련된 시스템 근처에 디스패쳐가 있다면 통상 디스패쳐는 외부에 있는 다양한 서버에 대해 스위치 역할을 하게 된다. 서버를 셀렉팅 하는 역할을 하는 것이다. 디스패쳐를 서버단에 넣게 되면, 외부에서 들어오는 리퀘스트를 디스패쳐가 받아서 이 서버의 하나에게 넘겨주는 형태의 역할을 하게 된다. 외부에서는 디스패쳐에게 대표로 주게 되는것. 이 디스패쳐를 가지고 있는 마스터가 있다. 이 마스터가 각 여러개의 서버중 하나에게 리퀘스트를 던져준다. 

많은 클라이언트들이 리퀘스트를 하게 되면 디스패쳐의 역할에 따라 전체 서버군을 이루는 서버들에게 로드를 밸런싱하는 효과를 얻게 되는 것이다. 

디스패쳐는 클라이언트에 붙이는 것 보다도 서버에 붙이는 것이 더 효과적이다. 로드밸런서로서 사용이 가능해지기 때문이다.  서버들이 부하 받지 않고 균형적이게 일을 처리하도록 함. 중간과정의 미들웨어를 형성하고 있다. 서버는 farms구조. 클라이언트는 마치 하나의 서버를 이용하는 효과. High scalability, high availability. 높은 이용률과 확장성.

하나의 서버가 모든 요청을 처리하게 되면 많은 트래픽에대한 처리는 어렵다. 이 서버를 scale up 해야 한다. 코어를 더 붙이거나 더 메모리를 붙이는 방법이다. 그런데 이 스케일업은 통상 짧은 교체 기간을 가지기에 좋지않다. 서버를 더 붙여 나갈 수 있는 scale out이 좋음. 트래픽이 증가 되더라도 서버를 계속해서 증가시켜 나가는 솔루션이 더 적절.

디스패쳐는 이런 스케일 아웃에 대한 솔루션. 어플리케이션에 대한 리퀘스트를 처리하도록 함. 

어플리케이션 세션을 유지할 필요성 있음. 많은경우 http프로토콜에서는 스테이트를 유지하지 않는다. 그래서 많은 방법을 이용하는데, 쿠키를 이용한다거나, 서버에서 세션을 유지시켜서 이용한다거나 http요청에 스테이트를 담아서 객체로 보내는 등 방법을 취한다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-29 오전 10.43.30.png" alt="스크린샷 2020-04-29 오전 10.43.30" style="zoom:67%;" />

들어오는 요청에 따라 로드 밸런서는 적절하게 서버에게 분배해서 넘겨줌. 

#### Availability

가용성, 서버가 계속 가동되어 서비스를 제공 하게 하는. uptime : failures사이의 서비스가 게재하는 시간을 업타임이라고 한다. 업타임의 반대는 다운타임. failure에 대해 수리하거나 디텍트, 보완 하거나 재 시작하는 등 모든 것을 의미.  업타임 동안 리퀘스트를 잘 처리하도록 하고 잘 유지되도록. 

High availability(HA) 라고 하고, 7일,24시간,365일 항상 동작하도록. 한 서버만 가지고는 Availability하게 할 수 없음. HA를 제공하기 위해서 여러 서버를 제공해야 한다. 한 서버가 실패하더라도 다른 서버가 투명하게 받아 처리 하게 해줄 수 있는 형태가 바람직 하다. 

#### Scalability

확장성. 기능적 확장이 있고, 시스템의 규모를 확장하는 것이있는데, Scalability는 규모의 확장을 말하는 것임. 성능 이슈와 더불어 확장을 게시한다. Res time 등을 만족하기 위함이다. 

High scalable system을 만족하기 위해 scale up 하지 않고 scale out해서 달성한다. 들어오는 리퀘스트를 서버들에게 분산시켜서 업무들을 다른 서버에서 할 수 있도록 함.

로드밸런서가 bottleneck하게 되지 않도록 주의. 로드밸런서는 리퀘스트를 전달만 하는 역할만 할것. 로드밸런서는 서버의 상태를 모니터 하고 적절하게 전달해야한다. 

어느 경우에는 로드 밸런서 자체를 여러개를 두는 경우도 있음.

#### Implementations

트랜스포트 레벨에서 로드밸런스 하는것을 생각해 볼 수 있다. 디스패쳐에서 패킷이 오면, 트랜스포트 레이어에서 열어봐서 서버단에 패킷을 넘기는 방법이 있다. DNS를 기반으로 하거나 TCP/IP에서 할 수도 있음.

어플리케이션레벨 로드 밸런싱도 있음. HTTP프로토콜로 생각 할 수 있다. 디스패쳐에서 어플리케이션레벨까지 열어보고 내용을 봐서 적절한 서버에 넘겨준다. 이러한 방법은 각 서버가 다른 역할을 한다고 할때 적절한 서버에게 넘겨주게 된다.

#### Solution

소프트웨어적으로 로드밸런스 가능하고 하드웨어적으로도 가능하다

##### 하드웨어

보통 베이직 인티그레이티드 서킷 레벨어서 하게 되어 하드웨어를 제작하여 파는것. 알테온 스위치 같은것. 고가의 하드웨어임. 트랜스포트 레이어에서 하드웨어적으로 오픈하고 로드밸런싱하는 제품이 있다. 좀더 빠르게 처리할 수 있는 솔루션.

##### 소프트웨어

소프트웨어를 디스패쳐에 역할을 담당하도록 하는 것. 들어오는 패킷을 보고 내용에 따라 처리. 보통 어플리케이션 레이어에서 많이 함. 들어오는 프로토콜에 내용까지 열어보고 어떠한 일이 적절하게 할당되는 것이 좋은지 정하기 때문에 보통 소프트웨어 레벨. 하지만 하드웨어처럼 트랜스포트에서 할수도 있지만 빨른 알고리즘 등을 이용할때.

##### DNS

트랜스포트에서 하는 경우인데, DNS단에서 로드밸런싱. DNS서버에서 하는것처럼 디스패쳐가 DNS베이스 로드 밸런싱.안단에 있는 프라이빗한 ip를 가지고 있고 들어올때 하나씩 준다. 외부에서는 디스패쳐에게 로지컬 네임이나 버츄얼 ip어드레스를 준다. 거기중 대표 주자로 받고, 실제로 ip어드레스가 있는 서버들이 있는데, 들어오는 패킷에 따라 서버들에게 적절하게 전달. 

적절한 글로벌 서버 로드밸런스 알고리즘을 가지게 됨. 적절하게 서버들에게 로드를 전달하게 된다.

##### TCP/IP

트랜스포트 레이어에서 적절하게 운용. 많은경우 소프트웨어적으로 풀게 된다. Linux virtual server(LVS) 등 을 가지고 처리. TCP forward를 어떻게 처리할 것인지 처리 등 가능. 

#### Example

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-29 오전 11.54.47.png" alt="스크린샷 2020-04-29 오전 11.54.47" style="zoom:67%;" />

로드 밸런스 예시.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-29 오전 11.56.39.png" alt="스크린샷 2020-04-29 오전 11.56.39" style="zoom:80%;" />

로드밸런스가 두개. 캐쉬 서버가 두개이다. 세션을 유지한다고 해보자. 어플리케이션과 관련된 세션을 유지할 필요가 있는데 그것을 수행하는 서버. 디비를 이용하는 경우도 있지만 이는 퍼포먼스상 문제로 캐쉬서버를 두게 됨. 어떤 경우 memcached하게 하는 경우도 존재. 

### 아키텍쳐

### SOA(Service Oriented Architecture)

각기 다른 서버에서 서비스를 제공한다고 할때, 브로커는 이 서비스를 제공 해주는데, 소아는 이 서비스들을 묶어 하나의 비지니스 모델을 만드는 것이다. 비행기라고 하면 예매 탑승 이동 등을 묶어서 제공.

소아는 비지니스 프로세스의 컨셉을 가지고 시작함. 서비스가 스스로 자신은 어떠한 서비스 입니다라는 것을 가지고 있다. 서버는 스스로 디파인하고 가지고 있는 메소드와 서비스, 인터페이스를 보여주어 어떻게 인보케이션 하는지 알려줌. 외부적으로 스탠다드한 인터페이스를 제공하여 운용 가능하도록 한다. 서버는 각각 독립적임. 

서버에 대한 정보를 서비스 디렉토리나 네이밍을 가진 레지스트리에서 제공함. 서버는 자신의 서비스를 등록하고 클라이언트에서 그것을 찾아 진행한다. 

![스크린샷 2020-05-16 오후 9.55.22](/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-16 오후 9.55.22.png)

#### 장점

루즈 커플링. 각 독립된 서버에 독립된 서비스구조라서 의존성이 없다. 구현도 각자 다른 언어로 가능 하기 때문에 유연성이 좋아짐. 

상호 호환적. 기술적으로 다른 서비스라도 상호 호환 가능함.

재사용성. 서버의 여러 서비스가 필요에 따라 다른 시스템에 제공 가능

필요에 따라 서비스를 여러개 두고 많이 사용하는 서비스에 대해 스케일 아웃 가능. 

## 아키텍쳐

### XML-Based Web Service

웹 서비스는 고유명사. 여러 기관들이 하나의 스탠다드하게 웹서비스라는 고유 명사를 만들었음. 서버쪽에 있는 서비스가 외부에서 접속해서 사용할 수 있도록 그것을 스탠다드화 시킨 프로토콜. 웹서비스는 프로토콜자체가 스탠다드. HTTP위에 올라간다. 인코딩 방식은 XML프로토콜을 SOAP을 이용한다. 

HTTP위에서 도큐멘드 오리엔티드하게 작업. 메세지 기반으로 서비스. RPC메세지도 가능하다. 이말은 XML도큐먼트로 RPC인보케이션을 부를수도 도큐멘트를 부를수도 있음. 모든 외부에서 접근 할 때 접근성과 접근 가능성이 높아짐. 

#### 구조

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-19 오후 9.48.44.png" alt="스크린샷 2020-05-19 오후 9.48.44" style="zoom:67%;" />

우측 하단이 서버쪽. 좋은 서비스가 있다고 할때 등록을 레지스트리에 하는것임. 마치 브로커와 같음. 등록한 곳에서 서비스를 인지. 서비스에 대한 XML로 디스크립션 해서 놓는다. 그것이 WSDL(Web services description language). 좌측 하단이 클라이언트. SOAP프로토콜을 이용하여 서비스를 요청.(Simple Object Access protocol) 

클라이언트와 서버군이 있는데, 서버에서는 레지스트리에 등록하고 클라이언트는 레지스트리에서 정보를 받아서 이용.

#### Web service

WSDL. 어떻게 이 서비스를 불러야 할지 나타나 있다. 이것은 XML형태로 이루어짐. 외부에서 WSDL를 통해 서비스 접근하여 이용함. HTTP 위에 있으며, XML serialization. 

#### Conversion RPC - SOAP

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-19 오후 9.56.13.png" alt="스크린샷 2020-05-19 오후 9.56.13" style="zoom:67%;" />

기존에 직접 연결이 RPC. 이것을 XML도큐멘트로 변화시켜서 HTTP에 실어 보내는 것이다. 브로커를 인보케이션 적인 형태로 본다면 웹 서비스는 이것을 HTTP위에서 하는것.

#### WS Semantics

HTTP위에 올리기 때문에 컨텐트를 얹을 수 있음. 이것이 컨트랙이 일어나기 때문에 시멘틱을 해줘야 한다. Legal agreement.

#### SOAP(cont'd)

soap은 프로토콜임. SOA 프로토콜 이라고도 함. Object 접근 프로토콜.  두가지 의미임. 

##### Service Oriented Architecture Protocol

서비스로 운용하는 그런 구조로 된 프로토콜. 서비스가 여러가지 있을때 컴포지션 등.. 서비스 호출하거나 서비스의 결과를 반영한다거나 그러한 일들을 제공 할 수 있는 프로토콜이다. 서비스에 인터페이스 정의 스탠다드화.

##### Simple Object Access Protocol

오브젝트를 분산적으로 있는 외부 리모트 오브젝트를 접근하게 할때 간단하게 접근할수 있도록 하는 프로토콜. RPC에다가 웹 서비스를 붙이면 스탠다드화 되어서 외부 것 이용 가능하다고 했었음. RPC의 스탠다드한 웹 서비스를 위한 것.

#### SOAP message

헤더와 바디가 있음. 헤더는 보안이슈나 어디서부터 어디까지 간다를 가지고 있는것. 중간단계의 관련된 서비스가 들어있기도. 바디는 주로 컨텐트를 가짐. 무엇을 해야하고 어떤일을 할지 내포 되어 있음. XML베이스는 SOAP 메세지가 HTTP위에 스탠다드화 하여 올라가서 쉽게 이용 가능.

#### WSDL(Web service Description Language)

서비스에 대한 데이터 정보를 WSLD을 통해서 한다. 이것을 통해 웹서비스가 어떤 기능이 있다는 것을 알려주는 셀프 디스크리빙이 가능함. 어떻게 불러달라는 정보가 다 담겨져 있음. 이 웹서비스의 인터페이스를 포함하는 컨텐트를 가지고 있음. 이 서비스를 호출하려면 어떻게 해야하는지 정보가 모두 담겨 있다고 할 수 있다. 엔드포인트에 어떻게 접근 해야하는지 다 나와있음. 부를 때 어떤 형태로 불러야 하는지 정보를 담고 있다.

보통 프로그램을 짜고 IDLE에서 웹서비스화 하겠다 하면 거기서 자동으로 만들어준다. 

#### BPEL(Business Process Execution Language)

XML임. 존재하는 웹서비스가 어떻게 같이 엮여서 원하는 흐름대로 진행하면 전체적인 워크플로우가 완성되는지를 제공할 수 있는 XML doc. 웹서비스에 워크플로우를 담당하고 비펠에 따라 엔진이 있으면 하나하나 서비스를 인보케이션 해나감. 

어떠어떠한 순차에 따라 일을하면 된다는 뭐 그런거..?

#### Web service business process model 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-19 오후 10.56.50.png" alt="스크린샷 2020-05-19 오후 10.56.50" style="zoom:67%;" />

서비스의 순서가 다르게 적용되면 안됨. 비펠에서 잘 정의되고 그것에 따라 실행.

#### 

## 아키텍쳐

### Microservice

#### 예시

어떤 회사 e-commerce store운영중. 웹 어플리케이션을 가지고 있다. 여러가지 기능이 있는데 오더, 사용자 등록, 제품 검색, 주문 관리가 있다. 

시간이 지남에 따라 업무가 많아지고 기능이 복잡해짐. 경쟁회사 이용자 관리 잘 함. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-20 오전 11.23.19.png" alt="스크린샷 2020-05-20 오전 11.23.19" style="zoom:67%;" />

현재 한 팀이 수정을 가하면 모든 팀이 테스팅을 하고 수정하고 해야하는 형태로 되어있음. 작업을 빨리 디플로이 하고싶은데 어떻게 할까. 마이크로 서비스를 제공하자. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-20 오전 11.24.22.png" alt="스크린샷 2020-05-20 오전 11.24.22" style="zoom:67%;" />

기능과 관련하여 팀을 나눔. 결과론적으로 이 회사는 시대에 맞춰 업그레이드 하기위해 마이크로 서비스 운영. 짧은 시간동안 개발을 업그레이드 하고 경쟁사 대비 우위구조로 갈수 있다. 

#### In wiki

소프트웨어 디벨롶 테크닉. 소아의 일종. 소아는 단지 어플리케이션 형태로 되어있음. 마이크로 서비스는 서비스가 파인 그렌인한것임. 서비스의 작업이 매우 작은 사이즈라는 것임. 프로토콜도 무게가 가볍다. 소아와 유사한 구조고 서비스를 게제하지만, 파인 그레인하고 프로토콜이 가볍다는 것이 다르다.

#### 시놉시스

loosely coupled service oriented. 소아 구조임. 컨텍스트가 제한이 된다. 제한된 형태의 구조를 가지고 있는 소아. 하나의 싱글 어플리케이션을 아주 작은 크기의 서비스로 구성함. HTTP API

기능적으로 하는일을 디컴포지션함. 기능적인 사항에 따라서 팀을 분리를 하고 그 팀에서 작업을 개발하고 처리하고 수정 테슨팅 모두 하도록 한다.  전체 시스템을 기능적으로 디컴포지션. 기능적으로 관리하고 독립적으로 디플로이먼트시킴. 다른 팀에서 만든 각자 자기의 업무를 개발하고 배포까지 하도록 함. 풀리 오토메이티드 디플로이멘트한 작업까지 가능.

#### 아키텍처 스타일

비지니스 도메인에 대한 기능적인 분해. 기능적인 사항을 모듈화. 

#### Domain Driven Design(DDD)

비지니스 콘셉에 대해 복잡도가 올라가고 있을때 도메인 모델에 대해 내용을 파악해서 소프트웨어 개발을 하는것이 좋다. 은행이라고 할때 은행에 관련된 업무를 파악해야 잘 개발할 수 있다. 

도메인 별로 한덩어리로 하는것이 아니라 서브 도메인을 나누어 개발 진행. 

## 아키텍처

### 마이크로 서비스 - cases

#### 온라인 스토어 서비스

기능적으로 분해를 하는 디컴포지션을 어떻게 할 것이냐.

온라인 스토어에는 오더링 빌링 인벤토리 어카운팅(회계)이 있다.

![스크린샷 2020-05-21 오후 6.28.28](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-05-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.28.28.png?lastModify=1592460699)

- 오더링

  커스터머가 오더를 해서 아이템의 일을 하도록 함. 

- 빌링

  오더를 받아 아이템에 대한 인보이스를 가질 수 있다. 

- 인벤토리

  인벤토리는 아이템아 따라 일을 처리.

- 어카운팅

  결제와 같은 것들.

오더가 일어나면 오더링 프로세스에서는 여러가지 일들을 하면서 인보이스를 만들어서 빌링 서비스에 보내줌. 인벤토리 서비스에는 스탁을 업데이트 한다. 빌링 서비스는 물건이 판매가 되었으므로 자금 상태가 변화되니 어카운팅 서비스에 업데이트. 

#### Conway's law

1960년도에 생겨난 법칙. 멜빈 컨웨이라는 분이 아이디어를 냈음. 1960년대에는 큰 메인 프레임에 포커싱을 맞춘 일들이 많아서 컨웨이가 이야기하는 소프트웨를 개발할 때에는 이렇게 하는 것이 좋다 하는 것이 잘 받아들여지지 않았지만 차후에 이것이 마이크로 서비스와 유사해서 많이 받아들이게 되었음. 

모든 팀들이 한꺼번에 달려들어 개발을 함. 그렇게 하면 효율성이 떨어짐. 기능적으로 팀을 나누어서 처리하는 것이 좋다. 오더링을 잘하는 사람들끼리 모아서 팀을 꾸리고 각 기능별로 잘하는 사람들을 모아 팀을 꾸려서 개발 하도록 한다. 

#### 예제

![스크린샷 2020-05-21 오후 6.34.33](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-05-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.34.33.png?lastModify=1592460699)

이 예제를 잘 보면 각 서비스 별로 디비가 있다. 나갈때에는 이벤트 관을 통해서 나간다. 디비가 많기 때문에 이 마이크로 서비스를 운영할 때에는 디비를 잘 운용할 줄 알아야 한다. 마이크로 서비스를 분해할 때에는 다른 서비스와 최소로 통신하는 양상을 보여야 한다. 디비를 공유하거나 하면 좋지 않다. 

#### API Gateway

API gateway를 통해 다른 서비스들이 운용되고 있다. 레스트 API를 통해 일어난다. 각 프로토콜이 표준화 된다. 

![스크린샷 2020-05-21 오후 6.37.55](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-05-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.37.55.png?lastModify=1592460699)

실패가 일어날 때 마스킹 하는 효과. 문제가 생기는 서버는 감추고 운영 가능한 서버를 게재함. 어떤 실패가 일어난 서버는 오퍼레이션을 주지 않는다. 서비스의 위치 정보를 알아서 외부의 리퀘스트에 맞추어 전달함. 

#### VM

![스크린샷 2020-05-21 오후 6.41.13](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-05-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.41.13.png?lastModify=1592460699)

VM위에 마이크로 서비스를 돌릴 때에는 컨테이너 구조로 하는것이 라이트한 오퍼레이션을 제공할 수 있기에 더 좋다. 기능적인 바운디드 컨텍스트를 가지기에 컨테이너를 운영하면 더 가볍게 가능함.컨테이너의 라이브러리를 인보케이션 해서 작업을 수행한다.

### Communication

마이크로 서비스간 통신을 어떻게 할 것인가. 

HTTP : 가장 인기있는 OSI 7레이어 7어플리케이션 레이어에서 올라가는 표준화된 것. 

REST : 리소스의 로케이션을 리프레젠테이션 해주는 프로토콜. 데이터나 컨텐트를 리소스화 하여 유니폼 인터페이스를 만들어 주는 것. 

JSON : 데이터를 좀더 일반화 형태로 표현한 것. 

REST와 JSON이 가장 간편하게 표현하는 구조. 기존의 HTTP를 이용 하더라도 커뮤니케이션의 끝이 똑똑하기만 하면 더 간편하게 서비스를 게제 가능. 받는 쪽에서 프로토콜을 받을 때 내용을 보고 내용을 시멘틱하게 적절한 어플리케이션을 인보케이션 할 수 있다면 적절한 서비스가 이용 될 수 있다. - Smart endpoint, Dumb Pipes.

#### Feature

사이즈면에서는 작아진다. 아무리 큰 프로젝트라도 서브 팀으로 나누기 때문에 팀이 5~9명을 넘지않음. 효율적으로 개발 가능 하게 함. 기능 디컴포지션을 할때 vertical slicing. 독립적 개발을 할 수 있게 한다. 서로 팀에서 공유하는 스토리지나 디비가 없도록 한다. 떨어져있는 서비스 간에는 HTTP Restful interfaces 하는것이 바람직. 응집력 있게 일을 하는 것이 좋고, 만일 마이크로 서비스에서 한 팀의 업무량이 많아진다면, 스케일 아웃 한다. 필요한 마이크로 서비스에 따라 스케일 아웃, 스케일 인. 

##### 일반적 SOA vs 마이크로 서비스 

![스크린샷 2020-05-21 오후 6.53.05](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-05-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.53.05.png?lastModify=1592460699)

헤비한 오케스트레이션 엔진. SOAP을 프로토콜로 이용. 웹서비스를 사용. 라이센스가 커진다. 커뮤니케이션 자체는 인텔리젠트 커뮤니케이션 레이어가 들어가고 인티그레이티드 하는 것이 굉장히 중요한 업무.

마이크로 서비스는 아주 작은 사이즈. HTTP/REST/JSON으로 컴비네이션. 오케스트레이션이 아니고 choreography. 안무임. 어떤일을 하면 그때만 딱 동작. 큰 일보다도 작은 기능적 오퍼레이션이 컨텍스트에 맞춰 운용. Dumb communication Layer. 끝을 스마트한 엔드포인트. 인텔리젠트 서비스를 엔드포인트에 붙임. 관건은 아키텍쳐를 어떻게 구조를 잡는지를 잘 할 수록 전반적인 효율성이 영향 미친다. 

##### 보통의 SOA : Limit if Monolith Feature

![스크린샷 2020-05-21 오후 8.44.13](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-05-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.44.13.png?lastModify=1592460699)

##### 마이크로 서비스

![스크린샷 2020-05-21 오후 8.44.53](file:///Users/gilwoongkang/School/2001-note/%E1%84%89%E1%85%A9%E1%84%8B%E1%85%A1/image/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-05-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.44.53.png?lastModify=1592460699)

#### 아키텍쳐 어스펙트 마이크로 아키텍쳐

바운디드 컨텍스트. 하나의 기능적인 오퍼레이션. 싱글 리스폰시빌리티. 오케스트레이션이 아니라 choreographed. Smart endpoint & dump pipe, APIgate, Polyglot. 

#### 테크니컬 어스펙트 마이크로 아키텍처

각자 서비스가 그 프로세스를 담당하도록. 만일 실패하면 아이솔레이트. HTTP 프로토콜 위에서 돌아가서 stateless. 디플로이가 인디펜던트함. 배치도 다른 인스턴스에 배치 가능. 스케일도 인디펜던트. 디비도 따로 관리함이 옳다.

#### organizational aspects

팀이 그 일을 할 수 있도록. 프로덕트 위주로 단위별로 프로젝트. 작은 팀. 만든 팀이 운영까지 하도록. 분산되서 운영되도록 처리함. 

#### 퍼포먼스

모든 서비스가 다 필요한 서비스와 연결하여 커뮤니케이션. 마셜링에 시간이 많이 든다. 코드 듀플리케이션이 있을수도. 트랜섹션이 일어날 수도있는데 어떻게 할 것인지. 하나의 서비스보다 트랜섹션 바운더리로 생각을 하면 될 것임. HTTP프로토콜 위에서 일어나기 때문에 REST서비스가 상태를 저장하지 않음. 트랙섹션 처리를 한다는 것은 고민하면서 서로 커뮤니케이션 구조를 가져야 한다. 배치를 배치 자체만 하는 것이 아닌, 어떤 세트로 고민 하는 것이 좋음. 예를 들어 Spring cloud + Spring boot. 새로운 서비스를 계속 독립적으로 만들어 가면서 론칭 할 수 있음. 다른 종류의 서비스를 계속해서 빠르게 진행되서 론칭 할 수있음.

컨웨이 법칙에 따르면 기능적인 디컴포지션을 어떻게 잘라서 처리를 하느냐가 중요. 아키텍트의 역량이 더 중요함. 모든 구조가 모듈 형태로 됨. 모듈러한 시스템이 더 좋은 비용을 절감하는 구조. 

커뮤니케이션 오버헤드 생길수도. 커뮤니케이션을 가끔 하는 것이 좋다. 그렇다면 서비스가 커야 좋은가 ? 고민해볼 필요. 애자일 팀으로 팀 크기를 고려해야함. 인프라 스트럭쳐는 데으옾 인프라. 

디플로이가 가능하도록 하려면 또 작게 할필요 있음. 헤비하게 할지 작게 할지 디비와 연결하는 사이즈 등 고려많이 해야.

## Implicit Asynchronous Communication

커뮤니케이션 한다는 것은 OSI 7Layer같은 것을 말하는 것이 아닌, 아키텍트 내 타 모듈간의 커뮤니케이션을 말하는 것이다. 

- 두 파티션

| publisher | subscriber |
| --------- | ---------- |
| sender    | receiver   |
| producer  | consumer   |
| source    | target     |

두 파티션간 소통에는 다음 세가지 존재

- One to one ( message queue)

- one to many(message topic)

- or many to one (event based)

### Explicit vs Implicit invocation

Explicti은 눈으로 보이는 invocation. 직접 호출한다고 보면 된다.

Implicit은 트리거가 있어서 이벤트 트리거를 통해 호출하게 된다. 

옵저버는 Subject를 직접 확인하는 구조인데, Pub/Sub는 중간에 이벤트 채널이 존재해 중간 매개체 가지고 이용한다. (직접 확인하는 형태가 아님.)

### Implicit Asynchronous

두가지 모드

- Non buffered Event based 

  이벤트로 모든것을 처리한다. 옵저버나 이벤트 리스너 등.

- Buffered Messaged based

  중간에 버퍼를 두고 담을곳을 제공한다. 메세지큐나 메세지 토픽.

보내고 받는쪽을 구조화 하여 이용하게 된다 (pub/sub or producer/consumer)

버퍼를 이용하여 클라/서버간 Async하게 이용하고 큐의 강점을 살림. 메세지 큐는 one to one 이나 point to point. 메세지 토픽은 one to many에서 이용된다.

#### Non berffered Event based implicit

Event source 와 event listener로 구성됌. 이벤트를 만드는것과 듣는것으로 만들어진 형태. 버퍼의 설계가 필요없다. 내부적으로 들어가면 사실 버퍼가 존재한다. 하지만 아키텍트가 고려하지 않는다. 이벤트 자체에 대한 내용이 버퍼에 들어가 있다. 

![스크린샷 2020-06-17 오후 1.34.32](/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 1.34.32.png)

이벤트가 존재하는 대부분의 어플리케이션을 포함한다. 데이터베이스 어플리케이션, CASE tool, 디버깅, Stock managing(주식관련). E-commerce(재고관리 시스템.)

- Framework availability
- Reuseability
- Maintenance and evolution
- Independency and flexible
- parallel

단, source와 destination이 분리되기 때문에 테스티이이 어려움. 단계가 존재하여 오버헤드가 일어남. 이벤트에 맞는 리스너를 구성해야함.

### Buffered message-based

- Message producers : 서비스 제공자

- message consumers : 사용자

- Message service provides : 중간 매게 제공자

셋은 asynchronously 하다. message queue or message topic 둘중에 적용된다. Message-oriented middleware(MOM)이라는 것으로 개발. Message 를 reliable하게 구성.

reliable, scalable, flexible하게 구성. async한 communication. Peer to peer 구조로도 가능하다. 루즈 커플드 하며 각 독립적임. 

message receiver가 항시 대기 상태가 아니여도 된다. sender와 receiver는 버퍼의 위치만 알면 되고 서로 몰라도 된다. 

엔터프라이즈 통합에서 시스템 통합을 위한 다리로 이용된다. 마이크로 MQ등에서 메세지 큐 메커니즘이 많이 이용된다. (+JMS, MDB - Message-Driven Bean)

---

##### Point to Point message (P2P, Peer to Peer 아님에 주의)

연결점이 생겨 보내고 받는곳을 결정한다. Message queue, senders, and receiver 필요하다. 큐에서 메세지가 사용되거나 만료될때까지 유지함. 이는 더 신뢰성 있다. 

##### Pub/Sub messageing (P&S)

누군가를 구독하는 형태. 허브와 유사한 형태의 아키텍처. 메세지 토픽으로 pub가 보내 놓으면 sub에서 메세지 토픽에 접근하여 가져옴. 게시판의 형태. 중간에 있는 큐의 인지만으로 정보 이용이 가능함. Pub/sub는 각자 알 필요 없음. 

---

Message based는 비동기 통신으로 구성된다.

Sync 없이 Async로 정보를 주고 받고. Scale up해서 이용할 수 있다. 구성 요소가 정보를 보내고 즉각적 응답을 기다리지 않고 계속 자체적으로 작동 가능하다. 

- 모든 노드 서로 알 필요 없음
- 동시 다발적 처리 가능
- 스케일 업/아웃 쉬움. 신뢰성 있음
- 루즈 커플링. 손실없는 메시지 지속성 메시지 우선순위 및 만료 설정 등

단, 큐사이즈를 정해야 하는데, 너무 크면 swaping문제가 발생한다. 

## Interaction oriented SA

- data module : 데이터 API 등. 데이터 추상화 미치 모든 핵심 비지니스 로직
- control module : 제어. view data 간 절차 진행에 대한 내용.모듈간 통신 및 제어 흐름
- view presentation module : 어떻게 하면 내용이 잘 나타날까 interact. 인터페이스 및 출력 프레젠테이션

키 포인트는 user, data, processing을 분리 한다는 것. 루즈 커플링은 explicit, implicit registration/notification 메소드를 호출함으로 가능함. 

두가지 존재

- Model-View-Controller (MVC) : 사람이 interactive하게 system과 연결.
- Presentation-Abstraction-Control(PAC) : Agent와 agent간. 디비없이 간단하고 가벼운 구조.

둘은 구조가 다르다. 구성은 유사하다. 

### MVC

유저가 I/F를 연결하여 App과 상호 작동하는 프로그램에서 많이 이용하는 형태. GUI시스템 등에서 이용. 유저가 데이터를 변경하면 반영하여 적용한다. 어떤 경우에는 이벤트를 받아 프레젠테이션 변경하여 이용하기도 한다. 

- Application Domain(Model) : 히든된 형태. 트리거 서비스 제공. Core functional services
- Display of the application's state(View) : 나타내 보이는 것. 유저 편하게 하는것. displaying the data
- Interaction with the model and the view(Controller) : 유저 요청 처리. 셀렉션 처리, 모델 생성 등. manage the user input requests.

만일 시스템이 크지 않은 경우, 컨트롤러와 뷰를 합치기도 한다. 

MVC는 프레임워크 툴킷대로 정의하고 이용하는 경우가 많다. view등 세밇라게 다루는것 편하게 하기 위해 그렇게 한다. 그런데 어느 때에는 프레임 워크 툴킷으로 인해 변경이 어려운 경우도 존재한다. 

뷰와 컨트롤러의 역할이 모호하는 등의 문제도 존재.

### PAC

여러 Agent의 interactive 한 요구도 추가 수용함. 시스템은 서로 협력하는 agent간 계층으로 분해된다. 

MVC와 다르게 여러 agent간 interactive하게 하는 역할에 따라 계층을 가진 형태임.

- Presentation
- Abstraction
- Control

MVC는 req받아 세션을 유지하고 model값 받아 view에게 주는것. PAC은 각 Agent마다 있고 타 Agent와 통신한다.

- Top level : 코어 데이터, 비지니스 로직
- bottom level : 데이터 및 출력을 제공
- middle level : 바텀 레벨을 조정.

한 에이전트는 PAC을 가진다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 2.23.43.png" alt="스크린샷 2020-06-17 오후 2.23.43" style="zoom:67%;" />

때문에 여러 에이전트 있는것에 대해 모두 PAC존재함. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 2.24.24.png" alt="스크린샷 2020-06-17 오후 2.24.24" style="zoom:67%;" />

최상단은 주로 컨트롤 하는 에이전트. 모든 에이전트는 컨트롤을 통해 통신한다. PAC은 에이전트의 레벨이 존재하고 에이전트간 서로 상호작용 하는 것이다.

PAC형태는 에이전트의 문제가 생기면 대체 가능하다는 장점이 있다. 하지만 에이전트 많아지면 연결 및 관리에 대한 문제가 발생하며 설계 할때에도 에이전트를 몇개나 구성할지에 대한 확실적 구성이 어렵다. 적절하게 설정해야 한다.



## Data Flow SA

데이터가 전체적으로 움직임. 움직이는 데이터에 오퍼레이션을 가한다. 데이터가 흐르고 중간에서 행위를 가함. 데이터와 오퍼레이션을 구분하여 제작해야 한다. 

데이터를 처리하는 엘리먼트로 나누어야 한다. 시스템에 맞춰 커넥션을 구성한다. 오퍼레이션 어디 구조에 있느냐에 따라 그래프 토폴로지를 가지고 데이터 흐름 이 있을 수 있다. 데이터 처리 순서를 지시하고 제어하는 데이터 처리 요소로 분해된다. 

데이터 포맷의 결정이 중요하다. 오퍼레이션은 데이터와 구분하여 독립적으로 구성 하여야 한다. 서브 시스템은 각 독립적이다. 이는 변경 가능성과 재사용성을 준다. 

App등 다양한 곳에서 이용된다. 타 시스템과는 데이터로 연결되는 방식이라 시스템 변경의 영향이 적다. 

세가지 종류가 존재한다. 

- Batch Sequential
- Pipe and Filter
- Process Control

위 2가지는 데이터 자체가 흐르는 형태 프로세스 컨트롤은 데이터 값에 따라 변경되는 형태이다. 

### Batch Sequential

배치 형태로 모였다가 한번에 처리한다. 한 서브 시스템에서 다른 서브 시스템으로 전체 데이터를 전달한다. 각 서스시스템은 이전 서브 시스템이 계산을 완료 하기 전까지 프로세스를 시작 할 수 없다. 전 단계의 오퍼레이션이 모두 수행 되어야 다음 수행이 가능하다. 오퍼레이션들 끼리는 서로 전혀 관련이 없다. 단일 방향 커넥션이고 순서가 중요하다. 데이터를 한번에 처리한다. 서로 관련이 없지만 서로 의존성을 가진다. 

예를들어 쉘 스크립트파일. 이전 작업이 수행 되어야 나머지 작업 수행 가능하다. 

서브시스템간 간단하게 분할 가능하고, 각 시스템은 처리와 출력을 생성하므로 독립형 프로그램일 수 있다. 단, 이것은 외부 컨트롤을 필요로 한다. (마치 main method 처럼). 상호 호환은 하지 않는다. 자기 일만을 처리하며 동시 처리가 불가능하다.

### Pipe and Filter

데이터 스르림을 처리하는 구조. 파이프를 통해 진행한다. 각 처리 단계는 필터 컴포넌트로 캡슐화 되어있다. 데이터는 인접한 필터 사이를 통과한다. 필터를 재 조합 하면 관련 시스템 군을 구축 할 수 있다. 즉 필요에 따라 필터들을 묶어서 이용하기도 한다.

데이터가 stream하게 계속 들어오는 구조이다. 

- 데이터 스트림

  데이터 소스, 필터, 파이프 , 데이터 싱크로 구성된다. 컴포넌트간 연결은 데이터 스트림이다. 선입 선출 버퍼. 바이트 오브 스트림이나 character등. 타 시스템으로 가는 경우 마셜링, 언 마셜링 필수 수행. 이에따라 오버헤드 있음.

- 필터

  각 파이프를 연결하고 오퍼레이션을 수행한다. 

- 파이프

  데이터를 담아 전송한다. 

동시 다발적 처리가 가능하다.

##### Pipe and Filter type

- Push only (Write only)
- Pull only (Read only)
- Pull/push (Read/Write)

연결점에서 필터가 어떻게 동작하느냐에 따라 세가지로 나뉨. 

- Active Filter

  파이프로부터 읽어서 내보내는 주체가 필터인 경우 (Pull/Push). Passive pipe와 함께 이용된다. Unix및 Java의 파이프 리더 클래스.

- Passive filter

  파이프가 active인 형태. 파이프가 밀어넣고 준비되면 가져간다. 

데이터 처리를 단계로 나누어 처리하고 각 단계에서 필터는 데이터를 점차적으로 소비하고 이동함. 데이터 포멧에 대한 정의가 필요함. 성능 향상을 위해 파이프라인 작업 수행 가능. 

필터들에 대해 동시 다발적 처리가 가능하다. 필터 필요에 따라 재사용이 가능하다. 디펜던시가 낮고 간단함. 유연성이 존재한다. 타 시스템과의 처리를 위해 마셜링 등을 수행해야 하므로 오버헤드가 존재한다.

### Process Control

임베디드에서 주로 이용한다. process control variable에 의해 제어한다. 서브시스템간 연결로 분해함. 계속적으로 이어지는 행위를 가진다. output이 계속해서 이어지는 것을 유지 하도록 한다. 예를들어 차선 제어나 보일러 시스템과 같은 시스템.

두개의 서브 시스템이 있다. process/controll. 컨트롤이 측정하여 프로세스에게 명령 전달하고 프로세스는 이를 실행한다. 

센서로 들어온 값을 컨트롤러가 분석해 핸들링 실시 한다.

변수를 정확하게 공식을 사용하여 제어하기 어려운 경우 이용한다(온도나 속도 등) HILS(hardware in the loop system). 하드웨어를 통해 얻은 데이터로 시스템이 제대로 동작하기 위해 컨트롤 하는것. 

### Summary of DFA

데이터가 흐르는 문제. 어떤 방향으로 흐를지 결정하고 subsystem을 할당. 통상 글로벌 변수는 허가하지 않음. 

- 파이프 앤 필터

  파이프를 통해 들어온 데이터가 필터를 거쳐 처리한다. 동시에 실행되는 특성. 데이터 흐름과 제어 흐름이 implicit.

- 배치 시퀀셜

  일괄 순차적 처리. 한군데다 모아서 처리한다. 입력 및 출력 순서로 배치 데이터를 처리하기에 병목 현상이 발생한다. 순차적으로 처리한다.

- 프로세스 컨트롤

  데이터의 값에 따라 결정하고 처리한다.



## Data Centered SA

데이터가 중장 집중 저장소. 독립적 컴포넌트거나 agent라는 특징이 있으며, explicit 또는 implicit 메소드로 불려짐.

두가지 스타일 존재

- Repository

  데이터 저장된 곳. 데이터가 저장되어있고, 이는 수동적임. 접근하는 클라이언트가 active하게 이용. 예를들어 DBMS, IDL 등 존재. 

- BlackBoard

  동일 구조이나 다른 특성을 지님. 스토리지와 다른 속성임. 데이터 저장소가 active하다. 외려 client가 passive. 전/후 데이터 트리거. 데이터를 보고 변경할지 확인한다. 

  블랙보드의 클라이언트는 knowledge source 또는 listeners, subscriber라고 불린다. 새로운 데이터에 대해 트리거 이벤트 발생. KS는 이에따라 행동한다. 

### Repository

유저가 접근하여 처리하는 아키텍쳐. 데이터가 모여있는 데이터 저장 장소가 존재하고 컴포넌트가 이에 접근한다. 세마포와 유사한 형태. 공유 레포 사용을 기반으로 소프트웨어 구성 요소의 통신 모델을 정의한다. 접근 위치를 알아야 하고 access할 수 있어야 한다.

##### 가상 저장소

여러 물리적 레포 위에 구축. 

##### 분산 저장소

분산 데이터베이스 시스템. 데이터는 네트워크로 연결된 사이트에 배포. 수직 또는 수평의 데이터 파티션과 중복된 데이터 동기화 및 네트워크 데이터 전송 비용문제 존재.

##### 장점

데이터 무결성. 확장 가승성 재사용성. 서로 직접 통신하지 않기 때문. 

##### 단점

데이터 저장소의 안정성 및 가용성이 중요한 문제. 데이터 구조 및 에이전트간 종속성. 데이터 구조 변화가 에이전트에 높은 영향. 

### BlackBoard

어떤 문제에 대해 순서를 차례대로 따라가면서 문제를 해결하는 것을 deterministic outcome이라고 하는데, 블랙 보드는 이 방법을 사용하지 않고 문제를 해결함. 블랙 보드는 마치 게시판에 문제를 올리고 accept하여 문제를 해결하는 형태. 각 문제는 agent가 푼다. agent는 parallel하게 동작하며, 블랙보드 사용의 이유는 Non-deterministic한 row data가 있을때 최적화 하며 문제 해결을 풀기 위함이다.

agent가 푼 문제를 다른 ageng가 이어 받아 문제를 해결한다.

다음의 경우 유용하다. 원시 데이터를 높은 레벨의 데이터 구조로 변환하고자 할때. 공통의 데이터 구조에서 협력적 독립적 프로그램 콜렉션을 풀고자 할때 

예시는 speech recognition.

먼저 사람의 소리를 아날로그로 받아온다. 그것을 세그멘테이션 한 뒤 분석하여 결과를 도출한다. 

- BlackBoard : 데이터 저장소. 데이터를 가짐.
- Knowledge Source : 구체적 지식을 가진 도메인. 자기 영역에 대한 지식이 있음 (가설이나 사실 등)
- Controller : 핸들링

블랙보드 값에 따라 KS메소드가 결정되는 형태. 데이터는 블랙보드에서 트리거 한다고 보면 된다. 블랙보드의 데이터 변경은 하나 이상의 일치하는 KS를 트리거하여 처리를 지속한다. 

데이터 변경은 처리의 결과로 인해 발생한다. Pub/Sub 형태를 띈다. 

알고리즘은 다른 알고리즘의 결과에 의해 작동된다. 불확실한 데이터와 근사 솔루션이 특징이다. 분석 알고리즘은 잠재적 병렬 처리가 유도된다. 항상 그 알고리즘이 적용되는 것이 아니다. 그때 상황에 따라 다르게 적용된다. 

KS는 자신이 풀수 있는것과 없는것이 정의 되어있어야 한다. 컨트롤이 블랙보드 위에서 루프를 돌며 모니터 한다. 그리고 KS를 블랙보드에 접근시켜 일을 처리시킨다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 5.05.02.png" alt="스크린샷 2020-06-17 오후 5.05.02" style="zoom:67%;" />

##### Rule based 

KS에 rule이 있다. 이 법칙에 따라 추론 하도록 한다. 이 규칙과 활동 메커니즘을 플랙보드 트리거에 제공한다(룰 베잇스 전문 시스템). 각 KS는 자체 전략에 따라 솔루션을 해결하고 총 솔루션에 기여한다. 

데이터가 모인 문제. 현재 데이터에 따라 KS가 어떻게 진행될지 OS가 핸들링 한다. 블랙 보드는 기본적으로 자체 활성화 시스템이다. 컨트롤러는 블랙보드 및 KS를 시작하는 역할만 수행한다. 또한 솔루션의 정도를 파악하여 처리할지 종료할지 결정함. 

블랙보드와 KS사이에 Pub/Sub 관계 존재함. 

컨설팅과 같은 시스템을 예시로 사용할수 있는데 컨설팅의 경우 여러 솔루션을 제공함. 블랙보드의 경우 AI카테고리에 들어간다. 

##### 장단점

KS의 추가가 용이하다. Scale in/out. 동시 수행이 가능하며 재사용성 존재한다. 

가장 최적화된 값인지 파악하기가 어렵다. 우선순위에 대한 문제가 존재한다. 디버깅 및 테스팅이 매우 어렵다. 

## UP

다음 네가지 페이즈가 존재

- Inception

  As-Is 모델을 통해 현행 비지니스 프로세스의 문제점을 분석하고 스텍홀더가 기술한 비즈니스 비전이나 시스템 비전을 만족하기 위한 To-Be 모델을 만들어 시스템의 요구사항 식별 및 시스템의 범위를 결정함.

- Elaboration

  베이스라인 아키텍쳐를 작성하는 단계

- Construction

  실행 가능한 시스템을 만들어내는 단계

- Transition

  사용자에게 인도하는 단계

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 5.27.12.png" alt="스크린샷 2020-06-17 오후 5.27.12" style="zoom:67%;" />

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 5.28.57.png" alt="스크린샷 2020-06-17 오후 5.28.57" style="zoom:67%;" />

각 페이즈 끝날때 마일스톤이 나온다.

인셉션-엘라보레이션 : 비전, 스코프

엘라보레이션-컨스트럭션 : 베이스라인 아키텍쳐

컨스트럭션-트랜지션 : 이니셜 캐패빌리티 (작동상태)

최종 : 프로덕트 릴리즈.

### VS Agile

애자일은 긴급하고 빠르게. 큰 의미에서는 UP사이클에서 도출된다. 보드에서 작업을 지우는것이 애자일의 목적. 태스크별로 시행된다. 애자일은 디자인과 개발이 병행되며 주기가 짧음. 5명 이하의 팀으로 구성되곤 하는데 노련한 아키텍트와 신참 개발자들이 이루어지는 구조임. 

req가 자주 변경 되거나 스택홀더가 함께 할 경우 유리하다. 단 이것은 전체 구조가 안보이기 때문에 누군가가 이 UP를 관리/ 조정해야한다. 

Teamwork, adaptability, close collaboration에 집중된 형태임. 반복되고 점진적인 형태.

## Attribute Driven Design 

카네기 말론 대학에 있는 SEI에서 아키텍처 설계시 좀 더 매커니즘적으로 하는 알고리즘을 고안한 것. 비용 효율적, 반복적 도출 가능. 여러가지 재활용 가능한 디자인 스트래테지를 구성 가능하다. 

앞서 UP를 배웠는데, UP는 반복과 인크리멘탈(점진적)으로 완성도에 맞추어 가는 것. 

이에 반해 ADD는 시스테믹 하고 재귀적으로 문제를 계속 분해해가면서 분석하는 것. 재귀와 분해해 나가는 것이 핵심임. (Recursive, decomposition) 점점 분해해 나가면서 세부 설계 하는것. 아키텍처 스타일과 방안을 집어넣어 설계에 반영하는 개발 공정론.

기본적으로 

##### Plan

계획하고. 아키텍처를 구성하는 동기가 되는 요소. 어떤 엘리먼트를 선택하여 설계할지.

##### do 

실행하고. 세부 설계를 한다. 

##### check

검증함. 전체 구조가 적절한 다른 구조와 연결이 다 잘 되는지 점검.

위 세가지를 계속 반복한다. 아키텍처의 결과가 반영 될 때까지 지속. 

Add방법론은 전체 구조가 나왔으면 나누어 ADD를 실시하고 다시 실시하고...

 <img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 10.51.47.png" alt="스크린샷 2020-06-17 오후 10.51.47" style="zoom:67%;" />

하다보니까 일부가 또 디컴포지션 해야할거 같아.. 또하고. (예를들어 다른 패턴이라던가 스트레테지 패턴등의 이유로 더 쪼개는게 좋다고 고려 될 경우) 

전체 사이클이 리커시브하게 계속적으로 디컴포즈를 해 나가는 형태. 이렇게 하면 전체구조가 더 나은 방향으로 간다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 11.13.16.png" alt="스크린샷 2020-06-17 오후 11.13.16" style="zoom:67%;" />

아키텍처 드라이버가 있다. 이것을 스택홀더와 결정한 것. 목적이라던가 퀄리티 어트리뷰트, 기능 , 제한사항, 등이다. 그릭고 설계 전략이 있는데 아키텍트는 이 설계 전략을 가지고 구상하여 반영하는 것이다. 

### ADD 3.0

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-06-17 오후 11.14.44.png" alt="스크린샷 2020-06-17 오후 11.14.44" style="zoom:67%;" />

먼저 인풋을 가져온다. 드라이버를 선택한다. 그리고 우선순위 결정함. 기능성에 대해 선택해도 되고 퀄리티 어트리뷰트를 선택 할 수도있다. 이렇게 어트리뷰트를 선택한뒤 어디에 적용할지 선택함. 그에따라 디자인 컨셉을 결정함. 여기서 아케틱처 스타일을 적용한다. 아키텍처 스타일로 내부를 만들어 나간다. 동시에 책임을 주고, 이후 전체에 디한 뷰를 하고 이후 분석을 하고... 검토하고  여기까지 내용을 다시 반복한다. 

##### 1. 리뷰 인풋

서로 합의에 의해 결정한 사항. Purpose, primary functional requirements, quality attribute scenarios, constraints, concerns...

##### 2. 드라이버 선택

드라이버 5가지 중 어떠한 드라이버가 핵심인지 선택을 하게 됌. 선택한 것을 목표에 맞추어 설계. 드라이버 전체 요구사항을 만족할 때 설계 진행.

##### 3. 리파인 하기위해 엘리먼트 선택.

리파인은 디컴포지션이라는 의미가 들어감. 계속적으로 스타일을 넣으며 만드는것. 큰 덩이의 것을 작은것으로 나누면서 분해해가는 것. 하다보니 잘게 나누어진 것이 있는데 이것을 하나로 합친다. 어떤 오브젝트 형태로 만드는 것. 합쳐나가는 형태의 어프로치도 있음. 또 하나는 임프로브로, 이미 있는 엘리먼트인데 더 좋은 엘리먼트로 메소드를 더 만든다거나 이러한 작업을 하는것. 위의 것을 포함하는 것이 리파인이다. (세가지를 포함하는 의미임.)

##### 4. 하나 이상의 스타일을 선택한다.

아키텍처 스타일 등을 선택하여 집어넣음. 이외에도 디자인 패턴들을 적용한다거나도 가능. 

##### 5. 내부를 인스턴시에이트를 만들고 책임을 부여하고 인터페잉스를 정의함.

내부를 더 구체적으로 만들면서 외부와 잘 작동하게 함. 

##### 6. 전체 액티비티가 제대로 수행 되는지 테스트.

테스트. 추가 드라이버등 추가하는 행위

##### 7. 현재 설계 분석하고 리뷰한 다음 디자인 목적에 맞는지 점검.



상위 모듈에서 우리가 여러 드라이버들을 선택항여 상위 모듈을 디컴포즈 하여 리파인. 하위모듈로 분해하며 작업을 해나간다. 기존의 배웠던 아키텍쳐 스타일 가지고 목적을 달성하게 된다. 