## 아키텍쳐

### Layered Architecture Style

모든 클래스, 관련된 컴포넌트들을 하나의 레이어에 만들어 놓는것을 말한다. 전체 시스템을 레이어로 분리. 각 레이어별로 관련된 클래스들만 둘 수 있도록 한 것. 

전체 시스템을 레이어로 나눈다. 각 레이어에 관련된 클래스들을 두고 레이어가 연결 되게끔 설계한다. 이러한 스타일은 패키지, 디렉토리 구조안에 인캡슐레이션 된다고 보면 된다. 때때로 디플로이된 컴포넌트에 들어가기도 한다. 다른 프로젝트에 적재 되고 불러서 사용한다. 

#### 구조

i번째 레이어가 있다고 한다면 i+1 번째로 req보낸다고 한다면 (주로 api로 구성) 컨트롤러가 처리 한다던가 하는 구조. 인터페이스를 통해서 요청이 된다고 생각하면 된다. 각 레이어별로 캡슐화. 외부에서 내부 볼수 없음. api만 제공한다. 

주로 상단레이어에서 하단 레이어로 req보낸다. res는 상단으로 올라감.

#### OSI 7-Layer (예시)

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-11 오후 11.38.03.png" alt="스크린샷 2020-04-11 오후 11.38.03" style="zoom:50%;" />

각 레이어가 하는일을 레이어 내부에서 모두 처리되며 레이어 상단에서 하단으로 처리. 

##### Latered approach

전체 시스템으로 처리하는 것보다 레이어로 나누어 처리하는 것이 더 효율적. 팀별로 개발할때, 팀별로 점진적으로 개발할 때, 점차 증진되는 기능의 추가에서 테스트까지 수행하며 구현할때 유용하다.

#### Layered Architecture

각 레이어는 특별한 아레나를 가지고 있다. 그 레이어를 자세하게 내부 구현 볼 필요 없이 추상화 형태로 인터페이스만 뽕아서 보여주는게 좋다.

서로 관련된 것만 고려하고 나머지는 배제하는 형태를 취한다.

***"isolation concept"***

필요에따라 드라이버를 변경할때 해당 레이어만 변경하면 되므로 유연하게 대처도 가능하다.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-04-11 오후 11.45.24.png" alt="스크린샷 2020-04-11 오후 11.45.24" style="zoom:50%;" />

#### 스타일

일반적으로 adjacent. 하위 레이어 및 상단 레이어와 연결된 구조로 동작. 그러나 건너뛰는 경우도 존재. 이럴때는 bridge type connection를 이용하는데 이는 권장이 아님.

높은 레이어로 갈수록 좀더 일반적이로 application에 가까운, 클라이언트에 가까운 기능을 제공하고 밑으로 내려갈 수록 유틸리티나 세부적인 서비스를 제공한다고 볼 수 있다. 

넘버링은 하지 않는것이 좋다. 차후 레이어가 더 쪼개질 경우 변경 가능성에 의함. 

#### 구현

레이어는 어떤 경우에 deploy를 고려하여 구분하게 된다. 자바는 jar를 두고 다른 서버에 deploy할수 있는데, 관련 클래스 등을 전부 동봉 할 수 있다. 이런 패키지화 된 compressed한 파일은 deployed할수 있고, 클래스패스 등 환경을 신경쓰면 이용 가능하게 된다. 

#### 2 레이어

만일 레이어를 2개로 나눈다면 상단은 유저와 소통하게 되는 레이어, 하단은 처리를 하게되는 서비스를 제공하는 레이어가 될수 있겠다. (비지니스 로직이나 디비접근 등)

#### 어플리케이션 도메인

레이어 아키텍쳐는 유저가 일반화해서 쓸수 있는 어플리케이션 도메인에서 많이 사용하고 있다. 일반화 서비스를 위해 많이 이용. 레이어로 잘라서 일처리. 패키지별로 관련된 클래스가 같이 개발될수 있게 하고 때론 적재될 수 있도록 한다. 

#### 장점

소프트웨어 개발할때 점진적으로 완성을 하는 구조에 아주 적합한 아키텍쳐. 레이어를 무엇으로 구분할지 정하고 레이어를 하나씩 개발해 외부에 추상화로 제공한다. 레이어마다 독립성을 제공하고, 변경 가능성을 제공하고 있다. 그래서 유연하다. 재사용성 등 높음. 컴포넌트 베이스로 잡으려면 이러한 아키텍쳐 형태가 좋다. 플러그앤플레이 형태로 컴포넌트 제공가능. 코드가 다른 시스템에 이식이 쉽다. promotion of portability

#### 단점

가장 큰 문제는 퍼포먼스에서의 문제이다. 레이어를 거쳐서 일이 내부적으로 어떻게 처리되는지 모르면서 작업 요청만 하기 때문에 performance concerns of overhead 발생할 수도. 

통상 data marshaling and buffering에서 많이 먹음. 

레이어가 건너뛰는 경우, 데드락이 발생할 수 있음에 주의. 

예외처리와 핸들링의 경우. 레이어 안에서는 레이어 안에서 처리하게 됨이 옳다. 모르는 예외라고 자꾸 넘기게 되면 처리가 불가능하게 될 수도있다. 