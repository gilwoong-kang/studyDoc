## 아키텍처

### 마이크로 서비스 - cases

#### 온라인 스토어 서비스

기능적으로 분해를 하는 디컴포지션을 어떻게 할 것이냐.

온라인 스토어에는 오더링 빌링 인벤토리 어카운팅(회계)이 있다.

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-21 오후 6.28.28.png" alt="스크린샷 2020-05-21 오후 6.28.28" style="zoom:80%;" />

- 오더링

  커스터머가 오더를 해서 아이템의 일을 하도록 함. 

- 빌링

  오더를 받아 아이템에 대한 인보이스를 가질 수 있다. 

- 인벤토리

  인벤토리는 아이템아 따라 일을 처리.

- 어카운팅

  결제와 같은 것들.

오더가 일어나면 오더링 프로세스에서는 여러가지 일들을 하면서 인보이스를 만들어서 빌링 서비스에 보내줌. 인벤토리 서비스에는 스탁을 업데이트 한다. 빌링 서비스는 물건이 판매가 되었으므로 자금 상태가 변화되니 어카운팅 서비스에 업데이트. 

#### Conway's law

1960년도에 생겨난 법칙. 멜빈 컨웨이라는 분이 아이디어를 냈음. 1960년대에는 큰 메인 프레임에 포커싱을 맞춘 일들이 많아서 컨웨이가 이야기하는 소프트웨를 개발할 때에는 이렇게 하는 것이 좋다 하는 것이 잘 받아들여지지 않았지만 차후에 이것이 마이크로 서비스와 유사해서 많이 받아들이게 되었음. 

모든 팀들이 한꺼번에 달려들어 개발을 함. 그렇게 하면 효율성이 떨어짐. 기능적으로 팀을 나누어서 처리하는 것이 좋다. 오더링을 잘하는 사람들끼리 모아서 팀을 꾸리고 각 기능별로 잘하는 사람들을 모아 팀을 꾸려서 개발 하도록 한다. 

#### 예제

![스크린샷 2020-05-21 오후 6.34.33](/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-21 오후 6.34.33.png)

이 예제를 잘 보면 각 서비스 별로 디비가 있다. 나갈때에는 이벤트 관을 통해서 나간다. 디비가 많기 때문에 이 마이크로 서비스를 운영할 때에는 디비를 잘 운용할 줄 알아야 한다. 마이크로 서비스를 분해할 때에는 다른 서비스와 최소로 통신하는 양상을 보여야 한다. 디비를 공유하거나 하면 좋지 않다. 

#### API Gateway

API gateway를 통해 다른 서비스들이 운용되고 있다. 레스트 API를 통해 일어난다. 각 프로토콜이 표준화 된다. 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-21 오후 6.37.55.png" alt="스크린샷 2020-05-21 오후 6.37.55" style="zoom:67%;" />

실패가 일어날 때 마스킹 하는 효과. 문제가 생기는 서버는 감추고 운영 가능한 서버를 게재함. 어떤 실패가 일어난 서버는 오퍼레이션을 주지 않는다. 서비스의 위치 정보를 알아서 외부의 리퀘스트에 맞추어 전달함. 

#### VM

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-21 오후 6.41.13.png" alt="스크린샷 2020-05-21 오후 6.41.13" style="zoom:67%;" />

VM위에 마이크로 서비스를 돌릴 때에는 컨테이너 구조로 하는것이 라이트한 오퍼레이션을 제공할 수 있기에 더 좋다. 기능적인 바운디드 컨텍스트를 가지기에 컨테이너를 운영하면 더 가볍게 가능함.컨테이너의 라이브러리를 인보케이션 해서 작업을 수행한다.

### Communication

마이크로 서비스간 통신을 어떻게 할 것인가. 

HTTP : 가장 인기있는 OSI 7레이어 7어플리케이션 레이어에서 올라가는 표준화된 것. 

REST : 리소스의 로케이션을 리프레젠테이션 해주는 프로토콜. 데이터나 컨텐트를 리소스화 하여 유니폼 인터페이스를 만들어 주는 것. 

JSON : 데이터를 좀더 일반화 형태로 표현한 것. 

REST와 JSON이 가장 간편하게 표현하는 구조. 기존의 HTTP를 이용 하더라도 커뮤니케이션의 끝이 똑똑하기만 하면 더 간편하게 서비스를 게제 가능. 받는 쪽에서 프로토콜을 받을 때 내용을 보고 내용을 시멘틱하게 적절한 어플리케이션을 인보케이션 할 수 있다면 적절한 서비스가 이용 될 수 있다. - Smart endpoint, Dumb Pipes.

#### Feature

사이즈면에서는 작아진다. 아무리 큰 프로젝트라도 서브 팀으로 나누기 때문에 팀이 5~9명을 넘지않음. 효율적으로 개발 가능 하게 함. 기능 디컴포지션을 할때 vertical slicing. 독립적 개발을 할 수 있게 한다. 서로 팀에서 공유하는 스토리지나 디비가 없도록 한다. 떨어져있는 서비스 간에는 HTTP Restful interfaces 하는것이 바람직. 응집력 있게 일을 하는 것이 좋고, 만일 마이크로 서비스에서 한 팀의 업무량이 많아진다면, 스케일 아웃 한다. 필요한 마이크로 서비스에 따라 스케일 아웃, 스케일 인. 

##### 일반적 SOA vs 마이크로 서비스 

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-21 오후 6.53.05.png" alt="스크린샷 2020-05-21 오후 6.53.05" style="zoom:80%;" />

헤비한 오케스트레이션 엔진. SOAP을 프로토콜로 이용. 웹서비스를 사용. 라이센스가 커진다. 커뮤니케이션 자체는 인텔리젠트 커뮤니케이션 레이어가 들어가고 인티그레이티드 하는 것이 굉장히 중요한 업무.

마이크로 서비스는 아주 작은 사이즈. HTTP/REST/JSON으로 컴비네이션. 오케스트레이션이 아니고 choreography. 안무임. 어떤일을 하면 그때만 딱 동작. 큰 일보다도 작은 기능적 오퍼레이션이 컨텍스트에 맞춰 운용. Dumb communication Layer. 끝을 스마트한 엔드포인트. 인텔리젠트 서비스를 엔드포인트에 붙임. 관건은 아키텍쳐를 어떻게 구조를 잡는지를 잘 할 수록 전반적인 효율성이 영향 미친다. 

##### 보통의 SOA : Limit if Monolith Feature

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-21 오후 8.44.13.png" alt="스크린샷 2020-05-21 오후 8.44.13" style="zoom:67%;" />

##### 마이크로 서비스

<img src="/Users/gilwoongkang/School/2001-note/소아/image/스크린샷 2020-05-21 오후 8.44.53.png" alt="스크린샷 2020-05-21 오후 8.44.53" style="zoom:67%;" />

#### 아키텍쳐 어스펙트 마이크로 아키텍쳐

바운디드 컨텍스트. 하나의 기능적인 오퍼레이션. 싱글 리스폰시빌리티. 오케스트레이션이 아니라 choreographed. Smart endpoint & dump pipe, APIgate, Polyglot. 

#### 테크니컬 어스펙트 마이크로 아키텍처

각자 서비스가 그 프로세스를 담당하도록. 만일 실패하면 아이솔레이트. HTTP 프로토콜 위에서 돌아가서 stateless. 디플로이가 인디펜던트함. 배치도 다른 인스턴스에 배치 가능. 스케일도 인디펜던트. 디비도 따로 관리함이 옳다.

#### organizational aspects

팀이 그 일을 할 수 있도록. 프로덕트 위주로 단위별로 프로젝트. 작은 팀. 만든 팀이 운영까지 하도록. 분산되서 운영되도록 처리함. 

#### 퍼포먼스

모든 서비스가 다 필요한 서비스와 연결하여 커뮤니케이션. 마셜링에 시간이 많이 든다. 코드 듀플리케이션이 있을수도. 트랜섹션이 일어날 수도있는데 어떻게 할 것인지. 하나의 서비스보다 트랜섹션 바운더리로 생각을 하면 될 것임. HTTP프로토콜 위에서 일어나기 때문에 REST서비스가 상태를 저장하지 않음. 트랙섹션 처리를 한다는 것은 고민하면서 서로 커뮤니케이션 구조를 가져야 한다. 배치를 배치 자체만 하는 것이 아닌, 어떤 세트로 고민 하는 것이 좋음. 예를 들어 Spring cloud + Spring boot. 새로운 서비스를 계속 독립적으로 만들어 가면서 론칭 할 수 있음. 다른 종류의 서비스를 계속해서 빠르게 진행되서 론칭 할 수있음.

컨웨이 법칙에 따르면 기능적인 디컴포지션을 어떻게 잘라서 처리를 하느냐가 중요. 아키텍트의 역량이 더 중요함. 모든 구조가 모듈 형태로 됨. 모듈러한 시스템이 더 좋은 비용을 절감하는 구조. 

커뮤니케이션 오버헤드 생길수도. 커뮤니케이션을 가끔 하는 것이 좋다. 그렇다면 서비스가 커야 좋은가 ? 고민해볼 필요. 애자일 팀으로 팀 크기를 고려해야함. 인프라 스트럭쳐는 데으옾 인프라. 

디플로이가 가능하도록 하려면 또 작게 할필요 있음. 헤비하게 할지 작게 할지 디비와 연결하는 사이즈 등 고려많이 해야.